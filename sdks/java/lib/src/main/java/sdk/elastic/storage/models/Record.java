package sdk.elastic.storage.models;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;
import sdk.elastic.storage.flatc.records.KeyValue;
import sdk.elastic.storage.flatc.records.RecordMeta;

/**
 * A record generally wraps a message. It is the basic unit of data in the stream.
 * DO NOT encode a record directly, because RecordMeta can only be generated by {@link RecordBatch}.
 * Note that data nodes store records with a whole {@link RecordBatch} instead of a single {@link Record}.
 */
public class Record {
    public static final int ENCODED_MIN_LENGTH = 8;
    private final long streamId;
    private final long offset;
    private final long timestamp;
    private final Headers headers;
    private final Map<String, String> properties;
    private final ByteBuffer body;

    public Record(long streamId, long offset, long timestamp, Headers headers, Map<String, String> properties,
        ByteBuffer body) {
        this.streamId = streamId;
        this.offset = offset;
        this.timestamp = timestamp;
        this.headers = headers;
        this.properties = properties;
        this.body = body;
    }

    public Record(long streamId, long offset, Headers headers, Map<String, String> properties, ByteBuffer body) {
        this(streamId, offset, System.currentTimeMillis(), headers, properties, body);
    }

    public Record(ByteBuffer buffer, long streamId, long baseOffset, long baseTimestamp) {
        int metaLength = buffer.getInt();
        int bodyLength = buffer.getInt();

        assert buffer.remaining() >= metaLength + bodyLength;
        byte[] metaBytes = new byte[metaLength];
        buffer.get(metaBytes);
        RecordMeta meta = RecordMeta.getRootAsRecordMeta(ByteBuffer.wrap(metaBytes));

        this.streamId = streamId;
        this.offset = baseOffset + meta.offsetDelta();
        this.timestamp = baseTimestamp + meta.timestampDelta();
        if (meta.headersVector() != null && meta.headersLength() > 0) {
            this.headers = new Headers();
            for (int i = 0; i < meta.headersLength(); i++) {
                KeyValue keyValue = meta.headers(i);
                HeaderKey key = HeaderKey.valueOf(keyValue.key());
                this.headers.addHeader(key, keyValue.value());
            }
        } else {
            this.headers = null;
        }
        if (meta.propertiesVector() != null && meta.propertiesLength() > 0) {
            this.properties = new HashMap<>();
            for (int i = 0; i < meta.propertiesLength(); i++) {
                KeyValue keyValue = meta.properties(i);
                this.properties.put(keyValue.key(), keyValue.value());
            }
        } else {
            this.properties = null;
        }

        byte[] bodyBytes = new byte[bodyLength];
        buffer.get(bodyBytes);
        this.body = ByteBuffer.wrap(bodyBytes);
    }

    public long getOffset() {
        return offset;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public ByteBuffer getBody() {
        return body;
    }

    public Headers getHeaders() {
        return headers;
    }

    public Map<String, String> getProperties() {
        return properties;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        Record rhs = (Record) obj;
        return new org.apache.commons.lang3.builder.EqualsBuilder()
            .append(this.streamId, rhs.streamId)
            .append(this.offset, rhs.offset)
            .append(this.timestamp, rhs.timestamp)
            .append(this.headers, rhs.headers)
            .append(this.properties, rhs.properties)
            .append(this.body.duplicate(), rhs.body.duplicate())
            .isEquals();
    }
}
