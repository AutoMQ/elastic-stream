namespace header;

// Use HTTP status codes where possible: https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
// 5xx is not used as we have two kinds of servers: placement manager and data node. Instead, use
// 6xx for placement manager errors and 7xx for data node errors.
enum ErrorCode : int16 {
    NONE = 0,

    // 2xx means success or partial success.
    OK = 200,

    // 4xx for client errors
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    PAYMENT_REQUIRED = 402,
    FORBIDDEN = 403,
    NOT_FOUND = 404,
    METHOD_NOT_ALLOWED = 405,
    PRECONDITION_FAILED = 412,
    PAYLOAD_TOO_LARGE = 413,
    TOO_MANY_REQUESTS = 429,
    HEADER_FIELDS_TOO_LARGE = 431,

    // 6xx is reserved for placement manager errors
    // In case placement manager encounters an internal error, normally, this implies 
    // that a design or implementation bug is triggered and should be fixed.
    PM_INTERNAL_SERVER_ERROR = 600,

    // Feature not implemented yet.
    PM_NOT_IMPLEMENTED = 601,

    // When creating a new stream or sealing a mutable range, placement managers need to create
    // a new replica-set of mutable range, which requires at least replica number of survival 
    // data nodes. If this requirement is not met, this error code is employed to deliver the error
    // to caller client.
    PM_NO_AVAILABLE_DN = 602,

    // Placement manager nodes are running RAFT concensus algorithm, write operations should go to
    // leader nodes. Otherwise, use this code to err caller client and to redirect client future requests.
    PM_NOT_LEADER = 603,

    // 7xx is reserved for data node errors
    DN_INTERNAL_SERVER_ERROR = 700,
    DN_NOT_IMPLEMENTED = 701,
    DN_NOT_LEADER_RANGE = 702,
}

// The Status type defines a logical error model.
// Each `Status` message contains three pieces of data: error code, error message, and error detail.
table Status {
    // The top-level error code, or 0 if there was no error.
    code: ErrorCode (id: 0);
    // The error message, or omitted if there was no error.
    message: string (id: 1);
    // Additional information about the error, if any.
    // Its format depends on the specific `ErrorCode`.
    detail: [ubyte] (id: 2);
}

// The Placement Manager information.
// It will be set in `Status.detail` if the `Status.code` is `PM_NOT_LEADER`.
table PlacementManager {
    nodes: [PlacementManagerNode] (id: 0);
}

// A node in the Placement Manager.
table PlacementManagerNode {
    // The name of the PM node.
    name: string (id: 0);
    // The advertise address of the PM node, for client traffic from outside.
    // The schema of the address is `host:port`, while host supports both domain name and IPv4/IPv6 address.
    advertise_addr: string (id: 1);
    is_leader: bool (id: 2);
}

// The system error response is used to return the error code and error message if the system error flag of sbp is set.
table SystemErrorResponse {
    status: Status (id: 0);
}

enum ClientRole : byte {
    CLIENT_ROLE_UNKNOWN = 0,
    CLIENT_ROLE_PM = 1,
    CLIENT_ROLE_DATA_NODE = 2,
}

// The heartbeat is used to keep the connection alive.
table HeartbeatRequest {
    // The unique id of the client.
    client_id: string (id: 0);
    // The role of the client. The client role is used to determine the type of the client.
    client_role: ClientRole (id: 1);
    // Optional, the node information of the data node. Empty if the client is an SDK client.
    data_node: DataNode (id: 2);
}

table HeartbeatResponse {
    client_id: string (id: 0);
    client_role: ClientRole (id: 1);
    data_node: DataNode (id: 2);
    status: Status (id: 3);
}

// The append request is used to append records to the data node.
table AppendRequest {
    // The timeout to await a response in milliseconds.
    timeout_ms: int32 (id: 0);
    // A batch of append requests.
    append_requests: [AppendInfo] (id: 1);
}

table AppendInfo {
    // The id of the stream to append records.
    stream_id: int64 (id: 0);
    // The index of the request in the batch.
    request_index: int32 (id: 1);
    // The payload length of this record batch to append
    batch_length: int32 (id: 2);
}

table AppendResponse {
    // The time in milliseconds to throttle the client, due to a quota violation or the server is too busy.
    throttle_time_ms: int32 (id: 0);
    // A batch of append responses.
    append_responses: [AppendResult] (id: 1);
    status: Status (id: 2);
}

table AppendResult {
    // The id of the stream
    stream_id: int64 (id: 0);
    // The index of the request that this response is for.
    request_index: int32 (id: 1);
    // The offset of the first record in the record batch.
    base_offset: int64 (id: 2);
    // The timestamp returned by the data node server after appending the records.
    stream_append_time_ms: int64 (id: 3);
    status: Status (id: 4);
}

// The fetch request is used to fetch records from the data node.
// This frame supports fetching data from multiple streams in one frame,
// and the response could be split into multiple frames then returned in a streaming way.
table FetchRequest {
    // The maximum time in milliseconds to wait for the response.
    max_wait_ms: int32 (id: 0);
    // The minimum bytes to accumulate before returning a response.
    min_bytes: int32 (id: 1);
    // A batch of fetch requests to fetch data from different streams.
    fetch_requests: [FetchInfo] (id: 2);
}

table FetchInfo {
    // A specfic stream to fetch data from.
    stream_id: int64 (id: 0);
    // The index of the request in the batch.
    request_index: int32 (id: 1);
    // The offset to fetch from.
    fetch_offset: int64 (id: 2);
    // The maximum number of bytes to fetch.
    batch_max_bytes: int32 (id: 3);
}

table FetchResponse {
    // The time in milliseconds to throttle the client, due to a quota violation or the server is too busy.
    throttle_time_ms: int32 (id: 0);
    // A batch of fetch responses.
    fetch_responses: [FetchResult] (id: 1);
    status: Status (id: 2);
}

table FetchResult {
    // The id of the stream
    stream_id: int64 (id: 0);
    // The index of the request that this response is for.
    request_index: int32 (id: 1);
    // The data length of the returned batch is used to decode the data from the payload.
    batch_length: int32 (id: 2);
    status: Status (id: 3);
}

// Used to fetch the ranges from a specific data node or a specific stream list.
// Regard this table as a union type.
// Alway set one of the fields.
table RangeCriteria {
    data_node: DataNode (id: 0);
    // The stream id to list the ranges.
    stream_id: int64 (id: 1);
}

table DataNode {
    // The node id of the data node.
    node_id: int32 (id: 0);

    // The advertise address of the data node, for client traffic from outside.
    // The schema of the address is `host:port`, while host supports both domain name and IPv4/IPv6 address.
    advertise_addr: string (id: 1);
}

// The list streams request is used to list the ranges of a batch of streams.
// Or it could list the ranges of all the streams in a specific data node.
table ListRangesRequest {
    timeout_ms: int32 (id: 0);

    // The range criteria could be a data node or a list of streams.
    range_criteria: [RangeCriteria] (id: 1);
}

table ListRangesResponse {
    // The time in milliseconds to throttle the client, due to a quota violation or the server is too busy.
    throttle_time_ms: int32 (id: 0);
    // The responses of list ranges request
    list_responses: [ListRangesResult] (id: 1);
    status: Status (id: 2);
}

table ListRangesResult {
    // The criteria that the returned ranges used.
    // A criteria may be a data node or a stream id.
    range_criteria: RangeCriteria (id: 0);
    // The list of ranges.
    ranges: [Range] (id: 1);
    status: Status (id: 2);
}

table Range {
    // The id of the stream
    stream_id: int64 (id: 0);
    // The index of the range in the stream.
    range_index: int32 (id: 1);

    // The start offset of the range. Offset is 0-based index and follows left-boundary-inclusive and right-boundary-exclusive.
    start_offset: int64 (id: 2);

    // The end offset of the range.
    // -1 if the range is mutable. If the range is sealed, end_offset would be non-negative and `end_offset` is exclusive.
    //
    // For example, range `[0, -1)` means that it is still mutable and clients may append additional records to it;
    // range `[0, 100)` means it is already sealed and read-only, records indexed 0 to 99 can be retrieved from this range;
    // we may have empty, droppable sealed ranges with the form `[N, N)` and placement manager would delete them without hesitation,
    // as a result, clients should NOT cache these empty ones.
    end_offset: int64 (id: 3);

    // The next writable offset for incoming records of the range.
    // It's a snapshot of the next offset of the range, and it may be changed after the response is sent.
    next_offset: int64 (id: 4);
    // The set of all nodes that host this range.
    replica_nodes: [ReplicaNode] (id: 5);
}

table ReplicaNode {
    data_node: DataNode (id: 0);
    is_primary: bool (id: 1);
}

table SealRangesRequest {
    timeout_ms: int32 (id: 0);
    // The ranges to seal.
    ranges: [RangeId] (id: 1);
}

table RangeId {
    stream_id: int64 (id: 0);
    range_index: int32 (id: 1);
}

table SealRangesResponse {
    // The time in milliseconds to throttle the client, due to a quota violation or the server is too busy.
    throttle_time_ms: int32 (id: 0);
    // The responses of seal ranges request
    seal_responses: [SealRangesResult] (id: 1);
    status: Status (id: 2);
}

table SealRangesResult {
    // The id of the stream
    stream_id: int64 (id: 0);
    // The array of ranges, returned by the seal ranges request.
    // Both the PM and the data node will handle the seal ranges request.
    // Only the sealed ranges will be returned from the data node, while the sealed ranges and the newly writable ranges will be returned from the PM.
    ranges: [Range] (id: 1);
    status: Status (id: 2);
}

// The sync ranges request is used to sync newly writable ranges to accelerate the availability of a newly created writable range.
// Or, it could be used to assign a new replics of a range to a new data node.
table SyncRangesRequest {
    timeout_ms: int32 (id: 0);
    // The ranges to sync.
    stream_ranges: [StreamRanges] (id: 1);
}

// Contains the ranges of a specific stream.
table StreamRanges {
    stream_id: int64 (id: 0);
    ranges: [Range] (id: 1);
}

table SyncRangesResponse {
    // The time in milliseconds to throttle the client, due to a quota violation or the server is too busy.
    throttle_time_ms: int32 (id: 0);
    // The responses of sync ranges request
    sync_responses: [SyncRangesResult] (id: 1);
    status: Status (id: 2);
}

table SyncRangesResult {
    // The id of the stream
    stream_id: int64 (id: 0);
    // The array of ranges, returned by the sync ranges request.
    ranges: [Range] (id: 1);
    status: Status (id: 2);
}

// The describe ranges request is used to describe the ranges of a batch of streams.
// Usually, the client will use this frame to get the newly end offset of the stream after the write operation.
table DescribeRangesRequest {
    timeout_ms: int32 (id: 0);
    // The ranges to describe.
    ranges: [RangeId] (id: 1);
}

table DescribeRangesResponse {
    // The time in milliseconds to throttle the client, due to a quota violation or the server is too busy.
    throttle_time_ms: int32 (id: 0);
    // The responses of describe ranges request
    describe_responses: [DescribeRangeResult] (id: 1);
    status: Status (id: 2);
}

table DescribeRangeResult {
    // The id of the stream
    stream_id: int64 (id: 0);
    // The array of ranges, returned by the describe ranges request.
    ranges: Range (id: 1);
    status: Status (id: 2);
}

table Stream {
    // The id of the stream
    // Omitted if the stream is not created.
    stream_id: int64 (id: 0);
    // The number of replica of the stream.
    replica_nums: int8 (id: 1);
    // The time to live of records in the stream in milliseconds.
    retention_period_ms: int64 (id: 2);
}

// The create streams request is used to create a batch of streams.
// This frame with batch ability is very useful for importing metadata from other systems.
table CreateStreamsRequest {
    // The timeout in milliseconds to wait for the response.
    timeout_ms: int32 (id: 0);
    // A batch of streams to create.
    streams: [Stream] (id: 1);
}

table CreateStreamsResponse {
    // The time in milliseconds to throttle the client, due to a quota violation or the server is too busy.
    throttle_time_ms: int32 (id: 0);
    // The responses of create streams request
    create_responses: [CreateStreamResult] (id: 1);
    status: Status (id: 2);
}

table CreateStreamResult {
    // The created stream
    stream: Stream (id: 0);
    status: Status (id: 1);
}

// The delete streams request is used to delete a batch of streams to PM or data node.
// The PM will delete the stream metadata as well as the range info, while the data node only marks the stream as deleted to reject the new write requests timely.
table DeleteStreamsRequest {
    // The timeout in milliseconds to wait for the response.
    timeout_ms: int32 (id: 0);
    // The ids of the streams to delete.
    streams: [Stream] (id: 1);
}

table DeleteStreamsResponse {
    // The time in milliseconds to throttle the client, due to a quota violation or the server is too busy.
    throttle_time_ms: int32 (id: 0);
    // The responses of delete streams request
    delete_responses: [DeleteStreamResult] (id: 1);
    status: Status (id: 2);
}

table DeleteStreamResult {
    // The deleted stream, or omitted if the stream is not deleted.
    deleted_stream: Stream (id: 0);
    status: Status (id: 1);
}

table UpdateStreamsRequest {
    // The timeout in milliseconds to wait for the response.
    timeout_ms: int32 (id: 0);
    // The streams to update.
    streams: [Stream] (id: 1);
}

table UpdateStreamsResponse {
    // The time in milliseconds to throttle the client, due to a quota violation or the server is too busy.
    throttle_time_ms: int32 (id: 0);
    // The responses of update streams request
    update_responses: [UpdateStreamResult] (id: 1);
    status: Status (id: 2);
}

table UpdateStreamResult {
    // The updated stream
    stream: Stream (id: 0);
    status: Status (id: 1);
}

table DescribeStreamsRequest {
    // The timeout in milliseconds to wait for the response.
    timeout_ms: int32 (id: 0);
    // The ids of the streams to describe.
    stream_ids: [int64] (id: 1);
}

table DescribeStreamsResponse {
    // The time in milliseconds to throttle the client, due to a quota violation or the server is too busy.
    throttle_time_ms: int32 (id: 0);
    // The responses of describe streams request
    describe_responses: [DescribeStreamResult] (id: 1);
    status: Status (id: 2);
}

table DescribeStreamResult {
    // The stream, returned by the describe streams request.
    stream: Stream (id: 0);
    status: Status (id: 1);
}

// The trim streams request is used to trim a batch of streams to PM.
// The data node stores the records in the stream in a log structure,
// and the records are appended to the end of the log.
// Consider the length of disk is limited, the data node will delete the records to recycling the disk space.
// Once the deletion occurs, some ranges should be trimmed to avoid the clients to read the deleted records.

// The data node will send the TRIM_STREAMS frame to the PM to trim the stream with a trim offset.
// The PM will delete the ranges whose end offset is less than the trim offset
// and shrink the ranges whose start offset is less than the trim offset.

table TrimStreamsRequest {
    // The timeout in milliseconds to wait for the response.
    timeout_ms: int32 (id: 0);
    // The ids of the streams to trim.
    trimmed_streams: [TrimmedStream] (id: 1);
}

table TrimmedStream {
    // The id of the stream
    stream_id: int64 (id: 0);
    // The current minimum offset of the stream.
    // All the records before this offset have be deleted.
    trim_offset: int64 (id: 1);
}

table TrimStreamsResponse {
    // The time in milliseconds to throttle the client, due to a quota violation or the server is too busy.
    throttle_time_ms: int32 (id: 0);
    // The responses of trim streams request
    trim_responses: [TrimStreamResult] (id: 1);
    status: Status (id: 2);
}

table TrimStreamResult {
    // The trimmed stream
    trimmed_stream: Stream (id: 0);
    // The smallest range of the stream after a trim operation.
    range: Range (id: 1);
    status: Status (id: 2);
}

table ReportMetricsRequest {
    data_node: DataNode (id: 0);
    disk_in_rate: int64 (id: 1);
    disk_out_rate: int64 (id: 2);
    disk_free_space: int64 (id: 3);
    disk_unindexed_data_size: int64 (id: 4);
    memory_used: int64 (id: 5);
    uring_task_rate: int16 (id: 6);
    uring_inflight_task_cnt: int16 (id: 7);
    uring_pending_task_cnt: int32 (id: 8);
    uring_task_avg_latency: int16 (id: 9);
    network_append_rate: int16 (id: 10);
    network_fetch_rate: int16 (id: 11);
    network_failed_append_rate: int16 (id: 12);
    network_failed_fetch_rate: int16 (id: 13);
    network_append_avg_latency: int16 (id: 14);
    network_fetch_avg_latency: int16 (id: 15);
    range_missing_replica_cnt: int16 (id: 16);
    range_active_cnt: int16 (id: 17);
}

table ReportMetricsResponse {
    data_node: DataNode (id: 0);
    status: Status (id: 1);
}
