// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod header {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_ERROR_CODE: i16 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_ERROR_CODE: i16 = 2501;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_ERROR_CODE: [ErrorCode; 30] = [
        ErrorCode::ERROR_CODE_UNSPECIFIED,
        ErrorCode::ENCODE,
        ErrorCode::DECODE,
        ErrorCode::OK,
        ErrorCode::NO_NEW_RECORD,
        ErrorCode::BAD_REQUEST,
        ErrorCode::UNAUTHORIZED,
        ErrorCode::PAYMENT_REQUIRED,
        ErrorCode::FORBIDDEN,
        ErrorCode::NOT_FOUND,
        ErrorCode::METHOD_NOT_ALLOWED,
        ErrorCode::PRECONDITION_FAILED,
        ErrorCode::PAYLOAD_TOO_LARGE,
        ErrorCode::TOO_MANY_REQUESTS,
        ErrorCode::HEADER_FIELDS_TOO_LARGE,
        ErrorCode::UNAVAILABLE_FOR_LEGAL_REASONS,
        ErrorCode::RANGE_ALREADY_SEALED,
        ErrorCode::OFFSET_OVERFLOW,
        ErrorCode::RANGE_NOT_FOUND,
        ErrorCode::OFFSET_OUT_OF_RANGE_BOUNDS,
        ErrorCode::CREATE_RANGE_BEFORE_SEAL,
        ErrorCode::EXPIRED_RANGE_EPOCH,
        ErrorCode::UNSUPPORTED_OPERATION,
        ErrorCode::UNKNOWN_OPERATION,
        ErrorCode::PM_INTERNAL_SERVER_ERROR,
        ErrorCode::PM_NOT_IMPLEMENTED,
        ErrorCode::PM_NO_AVAILABLE_DN,
        ErrorCode::PM_NOT_LEADER,
        ErrorCode::DN_INTERNAL_SERVER_ERROR,
        ErrorCode::DN_NOT_IMPLEMENTED,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ErrorCode(pub i16);
    #[allow(non_upper_case_globals)]
    impl ErrorCode {
        pub const ERROR_CODE_UNSPECIFIED: Self = Self(0);
        pub const ENCODE: Self = Self(1);
        pub const DECODE: Self = Self(2);
        pub const OK: Self = Self(1200);
        pub const NO_NEW_RECORD: Self = Self(1204);
        pub const BAD_REQUEST: Self = Self(1400);
        pub const UNAUTHORIZED: Self = Self(1401);
        pub const PAYMENT_REQUIRED: Self = Self(1402);
        pub const FORBIDDEN: Self = Self(1403);
        pub const NOT_FOUND: Self = Self(1404);
        pub const METHOD_NOT_ALLOWED: Self = Self(1405);
        pub const PRECONDITION_FAILED: Self = Self(1412);
        pub const PAYLOAD_TOO_LARGE: Self = Self(1413);
        pub const TOO_MANY_REQUESTS: Self = Self(1429);
        pub const HEADER_FIELDS_TOO_LARGE: Self = Self(1431);
        pub const UNAVAILABLE_FOR_LEGAL_REASONS: Self = Self(1451);
        pub const RANGE_ALREADY_SEALED: Self = Self(1460);
        pub const OFFSET_OVERFLOW: Self = Self(1461);
        pub const RANGE_NOT_FOUND: Self = Self(1462);
        pub const OFFSET_OUT_OF_RANGE_BOUNDS: Self = Self(1463);
        pub const CREATE_RANGE_BEFORE_SEAL: Self = Self(1470);
        pub const EXPIRED_RANGE_EPOCH: Self = Self(1471);
        pub const UNSUPPORTED_OPERATION: Self = Self(1498);
        pub const UNKNOWN_OPERATION: Self = Self(1499);
        pub const PM_INTERNAL_SERVER_ERROR: Self = Self(1500);
        pub const PM_NOT_IMPLEMENTED: Self = Self(1501);
        pub const PM_NO_AVAILABLE_DN: Self = Self(1502);
        pub const PM_NOT_LEADER: Self = Self(1503);
        pub const DN_INTERNAL_SERVER_ERROR: Self = Self(2500);
        pub const DN_NOT_IMPLEMENTED: Self = Self(2501);

        pub const ENUM_MIN: i16 = 0;
        pub const ENUM_MAX: i16 = 2501;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::ERROR_CODE_UNSPECIFIED,
            Self::ENCODE,
            Self::DECODE,
            Self::OK,
            Self::NO_NEW_RECORD,
            Self::BAD_REQUEST,
            Self::UNAUTHORIZED,
            Self::PAYMENT_REQUIRED,
            Self::FORBIDDEN,
            Self::NOT_FOUND,
            Self::METHOD_NOT_ALLOWED,
            Self::PRECONDITION_FAILED,
            Self::PAYLOAD_TOO_LARGE,
            Self::TOO_MANY_REQUESTS,
            Self::HEADER_FIELDS_TOO_LARGE,
            Self::UNAVAILABLE_FOR_LEGAL_REASONS,
            Self::RANGE_ALREADY_SEALED,
            Self::OFFSET_OVERFLOW,
            Self::RANGE_NOT_FOUND,
            Self::OFFSET_OUT_OF_RANGE_BOUNDS,
            Self::CREATE_RANGE_BEFORE_SEAL,
            Self::EXPIRED_RANGE_EPOCH,
            Self::UNSUPPORTED_OPERATION,
            Self::UNKNOWN_OPERATION,
            Self::PM_INTERNAL_SERVER_ERROR,
            Self::PM_NOT_IMPLEMENTED,
            Self::PM_NO_AVAILABLE_DN,
            Self::PM_NOT_LEADER,
            Self::DN_INTERNAL_SERVER_ERROR,
            Self::DN_NOT_IMPLEMENTED,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::ERROR_CODE_UNSPECIFIED => Some("ERROR_CODE_UNSPECIFIED"),
                Self::ENCODE => Some("ENCODE"),
                Self::DECODE => Some("DECODE"),
                Self::OK => Some("OK"),
                Self::NO_NEW_RECORD => Some("NO_NEW_RECORD"),
                Self::BAD_REQUEST => Some("BAD_REQUEST"),
                Self::UNAUTHORIZED => Some("UNAUTHORIZED"),
                Self::PAYMENT_REQUIRED => Some("PAYMENT_REQUIRED"),
                Self::FORBIDDEN => Some("FORBIDDEN"),
                Self::NOT_FOUND => Some("NOT_FOUND"),
                Self::METHOD_NOT_ALLOWED => Some("METHOD_NOT_ALLOWED"),
                Self::PRECONDITION_FAILED => Some("PRECONDITION_FAILED"),
                Self::PAYLOAD_TOO_LARGE => Some("PAYLOAD_TOO_LARGE"),
                Self::TOO_MANY_REQUESTS => Some("TOO_MANY_REQUESTS"),
                Self::HEADER_FIELDS_TOO_LARGE => Some("HEADER_FIELDS_TOO_LARGE"),
                Self::UNAVAILABLE_FOR_LEGAL_REASONS => Some("UNAVAILABLE_FOR_LEGAL_REASONS"),
                Self::RANGE_ALREADY_SEALED => Some("RANGE_ALREADY_SEALED"),
                Self::OFFSET_OVERFLOW => Some("OFFSET_OVERFLOW"),
                Self::RANGE_NOT_FOUND => Some("RANGE_NOT_FOUND"),
                Self::OFFSET_OUT_OF_RANGE_BOUNDS => Some("OFFSET_OUT_OF_RANGE_BOUNDS"),
                Self::CREATE_RANGE_BEFORE_SEAL => Some("CREATE_RANGE_BEFORE_SEAL"),
                Self::EXPIRED_RANGE_EPOCH => Some("EXPIRED_RANGE_EPOCH"),
                Self::UNSUPPORTED_OPERATION => Some("UNSUPPORTED_OPERATION"),
                Self::UNKNOWN_OPERATION => Some("UNKNOWN_OPERATION"),
                Self::PM_INTERNAL_SERVER_ERROR => Some("PM_INTERNAL_SERVER_ERROR"),
                Self::PM_NOT_IMPLEMENTED => Some("PM_NOT_IMPLEMENTED"),
                Self::PM_NO_AVAILABLE_DN => Some("PM_NO_AVAILABLE_DN"),
                Self::PM_NOT_LEADER => Some("PM_NOT_LEADER"),
                Self::DN_INTERNAL_SERVER_ERROR => Some("DN_INTERNAL_SERVER_ERROR"),
                Self::DN_NOT_IMPLEMENTED => Some("DN_NOT_IMPLEMENTED"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ErrorCode {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ErrorCode {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i16>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ErrorCode {
        type Output = ErrorCode;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i16>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ErrorCode {
        type Scalar = i16;
        #[inline]
        fn to_little_endian(self) -> i16 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i16) -> Self {
            let b = i16::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ErrorCode {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i16::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ErrorCode {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_CLIENT_ROLE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_CLIENT_ROLE: i8 = 3;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_CLIENT_ROLE: [ClientRole; 4] = [
        ClientRole::CLIENT_ROLE_UNSPECIFIED,
        ClientRole::CLIENT_ROLE_PM,
        ClientRole::CLIENT_ROLE_DATA_NODE,
        ClientRole::CLIENT_ROLE_FRONTEND,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ClientRole(pub i8);
    #[allow(non_upper_case_globals)]
    impl ClientRole {
        pub const CLIENT_ROLE_UNSPECIFIED: Self = Self(0);
        pub const CLIENT_ROLE_PM: Self = Self(1);
        pub const CLIENT_ROLE_DATA_NODE: Self = Self(2);
        pub const CLIENT_ROLE_FRONTEND: Self = Self(3);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 3;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::CLIENT_ROLE_UNSPECIFIED,
            Self::CLIENT_ROLE_PM,
            Self::CLIENT_ROLE_DATA_NODE,
            Self::CLIENT_ROLE_FRONTEND,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::CLIENT_ROLE_UNSPECIFIED => Some("CLIENT_ROLE_UNSPECIFIED"),
                Self::CLIENT_ROLE_PM => Some("CLIENT_ROLE_PM"),
                Self::CLIENT_ROLE_DATA_NODE => Some("CLIENT_ROLE_DATA_NODE"),
                Self::CLIENT_ROLE_FRONTEND => Some("CLIENT_ROLE_FRONTEND"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ClientRole {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ClientRole {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ClientRole {
        type Output = ClientRole;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ClientRole {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ClientRole {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ClientRole {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_SEAL_KIND: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_SEAL_KIND: i8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_SEAL_KIND: [SealKind; 3] = [
        SealKind::UNSPECIFIED,
        SealKind::DATA_NODE,
        SealKind::PLACEMENT_MANAGER,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct SealKind(pub i8);
    #[allow(non_upper_case_globals)]
    impl SealKind {
        pub const UNSPECIFIED: Self = Self(0);
        pub const DATA_NODE: Self = Self(1);
        pub const PLACEMENT_MANAGER: Self = Self(2);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 2;
        pub const ENUM_VALUES: &'static [Self] =
            &[Self::UNSPECIFIED, Self::DATA_NODE, Self::PLACEMENT_MANAGER];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::UNSPECIFIED => Some("UNSPECIFIED"),
                Self::DATA_NODE => Some("DATA_NODE"),
                Self::PLACEMENT_MANAGER => Some("PLACEMENT_MANAGER"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for SealKind {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for SealKind {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for SealKind {
        type Output = SealKind;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for SealKind {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for SealKind {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for SealKind {}
    pub enum StatusOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Status<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Status<'a> {
        type Inner = Status<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Status<'a> {
        pub const VT_CODE: flatbuffers::VOffsetT = 4;
        pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;
        pub const VT_DETAIL: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Status { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StatusArgs<'args>,
        ) -> flatbuffers::WIPOffset<Status<'bldr>> {
            let mut builder = StatusBuilder::new(_fbb);
            if let Some(x) = args.detail {
                builder.add_detail(x);
            }
            if let Some(x) = args.message {
                builder.add_message(x);
            }
            builder.add_code(args.code);
            builder.finish()
        }

        pub fn unpack(&self) -> StatusT {
            let code = self.code();
            let message = self.message().map(|x| x.to_string());
            let detail = self.detail().map(|x| x.into_iter().collect());
            StatusT {
                code,
                message,
                detail,
            }
        }

        #[inline]
        pub fn code(&self) -> ErrorCode {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ErrorCode>(Status::VT_CODE, Some(ErrorCode::ERROR_CODE_UNSPECIFIED))
                    .unwrap()
            }
        }
        #[inline]
        pub fn message(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Status::VT_MESSAGE, None)
            }
        }
        #[inline]
        pub fn detail(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Status::VT_DETAIL,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Status<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ErrorCode>("code", Self::VT_CODE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "message",
                    Self::VT_MESSAGE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "detail",
                    Self::VT_DETAIL,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct StatusArgs<'a> {
        pub code: ErrorCode,
        pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        pub detail: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for StatusArgs<'a> {
        #[inline]
        fn default() -> Self {
            StatusArgs {
                code: ErrorCode::ERROR_CODE_UNSPECIFIED,
                message: None,
                detail: None,
            }
        }
    }

    pub struct StatusBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StatusBuilder<'a, 'b> {
        #[inline]
        pub fn add_code(&mut self, code: ErrorCode) {
            self.fbb_.push_slot::<ErrorCode>(
                Status::VT_CODE,
                code,
                ErrorCode::ERROR_CODE_UNSPECIFIED,
            );
        }
        #[inline]
        pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Status::VT_MESSAGE, message);
        }
        #[inline]
        pub fn add_detail(&mut self, detail: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Status::VT_DETAIL, detail);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StatusBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StatusBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Status<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Status<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Status");
            ds.field("code", &self.code());
            ds.field("message", &self.message());
            ds.field("detail", &self.detail());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct StatusT {
        pub code: ErrorCode,
        pub message: Option<String>,
        pub detail: Option<Vec<u8>>,
    }
    impl Default for StatusT {
        fn default() -> Self {
            Self {
                code: ErrorCode::ERROR_CODE_UNSPECIFIED,
                message: None,
                detail: None,
            }
        }
    }
    impl StatusT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Status<'b>> {
            let code = self.code;
            let message = self.message.as_ref().map(|x| _fbb.create_string(x));
            let detail = self.detail.as_ref().map(|x| _fbb.create_vector(x));
            Status::create(
                _fbb,
                &StatusArgs {
                    code,
                    message,
                    detail,
                },
            )
        }
    }
    pub enum PlacementManagerClusterOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PlacementManagerCluster<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PlacementManagerCluster<'a> {
        type Inner = PlacementManagerCluster<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PlacementManagerCluster<'a> {
        pub const VT_NODES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PlacementManagerCluster { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PlacementManagerClusterArgs<'args>,
        ) -> flatbuffers::WIPOffset<PlacementManagerCluster<'bldr>> {
            let mut builder = PlacementManagerClusterBuilder::new(_fbb);
            if let Some(x) = args.nodes {
                builder.add_nodes(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> PlacementManagerClusterT {
            let nodes = {
                let x = self.nodes();
                x.iter().map(|t| t.unpack()).collect()
            };
            PlacementManagerClusterT { nodes }
        }

        #[inline]
        pub fn nodes(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlacementManagerNode<'a>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlacementManagerNode>>,
                    >>(PlacementManagerCluster::VT_NODES, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for PlacementManagerCluster<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlacementManagerNode>>,
                >>("nodes", Self::VT_NODES, true)?
                .finish();
            Ok(())
        }
    }
    pub struct PlacementManagerClusterArgs<'a> {
        pub nodes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlacementManagerNode<'a>>>,
            >,
        >,
    }
    impl<'a> Default for PlacementManagerClusterArgs<'a> {
        #[inline]
        fn default() -> Self {
            PlacementManagerClusterArgs {
                nodes: None, // required field
            }
        }
    }

    pub struct PlacementManagerClusterBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PlacementManagerClusterBuilder<'a, 'b> {
        #[inline]
        pub fn add_nodes(
            &mut self,
            nodes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PlacementManagerNode<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                PlacementManagerCluster::VT_NODES,
                nodes,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PlacementManagerClusterBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PlacementManagerClusterBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PlacementManagerCluster<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, PlacementManagerCluster::VT_NODES, "nodes");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PlacementManagerCluster<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PlacementManagerCluster");
            ds.field("nodes", &self.nodes());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct PlacementManagerClusterT {
        pub nodes: Vec<PlacementManagerNodeT>,
    }
    impl Default for PlacementManagerClusterT {
        fn default() -> Self {
            Self {
                nodes: Default::default(),
            }
        }
    }
    impl PlacementManagerClusterT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<PlacementManagerCluster<'b>> {
            let nodes = Some({
                let x = &self.nodes;
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            PlacementManagerCluster::create(_fbb, &PlacementManagerClusterArgs { nodes })
        }
    }
    pub enum PlacementManagerNodeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PlacementManagerNode<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PlacementManagerNode<'a> {
        type Inner = PlacementManagerNode<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PlacementManagerNode<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_ADVERTISE_ADDR: flatbuffers::VOffsetT = 6;
        pub const VT_IS_LEADER: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PlacementManagerNode { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PlacementManagerNodeArgs<'args>,
        ) -> flatbuffers::WIPOffset<PlacementManagerNode<'bldr>> {
            let mut builder = PlacementManagerNodeBuilder::new(_fbb);
            if let Some(x) = args.advertise_addr {
                builder.add_advertise_addr(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_is_leader(args.is_leader);
            builder.finish()
        }

        pub fn unpack(&self) -> PlacementManagerNodeT {
            let name = {
                let x = self.name();
                x.to_string()
            };
            let advertise_addr = {
                let x = self.advertise_addr();
                x.to_string()
            };
            let is_leader = self.is_leader();
            PlacementManagerNodeT {
                name,
                advertise_addr,
                is_leader,
            }
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PlacementManagerNode::VT_NAME, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn advertise_addr(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(
                        PlacementManagerNode::VT_ADVERTISE_ADDR,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn is_leader(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(PlacementManagerNode::VT_IS_LEADER, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for PlacementManagerNode<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "advertise_addr",
                    Self::VT_ADVERTISE_ADDR,
                    true,
                )?
                .visit_field::<bool>("is_leader", Self::VT_IS_LEADER, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PlacementManagerNodeArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub advertise_addr: Option<flatbuffers::WIPOffset<&'a str>>,
        pub is_leader: bool,
    }
    impl<'a> Default for PlacementManagerNodeArgs<'a> {
        #[inline]
        fn default() -> Self {
            PlacementManagerNodeArgs {
                name: None,           // required field
                advertise_addr: None, // required field
                is_leader: false,
            }
        }
    }

    pub struct PlacementManagerNodeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PlacementManagerNodeBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PlacementManagerNode::VT_NAME, name);
        }
        #[inline]
        pub fn add_advertise_addr(&mut self, advertise_addr: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                PlacementManagerNode::VT_ADVERTISE_ADDR,
                advertise_addr,
            );
        }
        #[inline]
        pub fn add_is_leader(&mut self, is_leader: bool) {
            self.fbb_
                .push_slot::<bool>(PlacementManagerNode::VT_IS_LEADER, is_leader, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PlacementManagerNodeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PlacementManagerNodeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PlacementManagerNode<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, PlacementManagerNode::VT_NAME, "name");
            self.fbb_
                .required(o, PlacementManagerNode::VT_ADVERTISE_ADDR, "advertise_addr");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PlacementManagerNode<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PlacementManagerNode");
            ds.field("name", &self.name());
            ds.field("advertise_addr", &self.advertise_addr());
            ds.field("is_leader", &self.is_leader());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct PlacementManagerNodeT {
        pub name: String,
        pub advertise_addr: String,
        pub is_leader: bool,
    }
    impl Default for PlacementManagerNodeT {
        fn default() -> Self {
            Self {
                name: "".to_string(),
                advertise_addr: "".to_string(),
                is_leader: false,
            }
        }
    }
    impl PlacementManagerNodeT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<PlacementManagerNode<'b>> {
            let name = Some({
                let x = &self.name;
                _fbb.create_string(x)
            });
            let advertise_addr = Some({
                let x = &self.advertise_addr;
                _fbb.create_string(x)
            });
            let is_leader = self.is_leader;
            PlacementManagerNode::create(
                _fbb,
                &PlacementManagerNodeArgs {
                    name,
                    advertise_addr,
                    is_leader,
                },
            )
        }
    }
    pub enum SystemErrorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SystemError<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SystemError<'a> {
        type Inner = SystemError<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SystemError<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SystemError { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SystemErrorArgs<'args>,
        ) -> flatbuffers::WIPOffset<SystemError<'bldr>> {
            let mut builder = SystemErrorBuilder::new(_fbb);
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> SystemErrorT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            SystemErrorT { status }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(SystemError::VT_STATUS, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SystemError<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SystemErrorArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
    }
    impl<'a> Default for SystemErrorArgs<'a> {
        #[inline]
        fn default() -> Self {
            SystemErrorArgs {
                status: None, // required field
            }
        }
    }

    pub struct SystemErrorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SystemErrorBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(SystemError::VT_STATUS, status);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SystemErrorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SystemErrorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SystemError<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, SystemError::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SystemError<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SystemError");
            ds.field("status", &self.status());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SystemErrorT {
        pub status: Box<StatusT>,
    }
    impl Default for SystemErrorT {
        fn default() -> Self {
            Self {
                status: Default::default(),
            }
        }
    }
    impl SystemErrorT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<SystemError<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            SystemError::create(_fbb, &SystemErrorArgs { status })
        }
    }
    pub enum HeartbeatRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct HeartbeatRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for HeartbeatRequest<'a> {
        type Inner = HeartbeatRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> HeartbeatRequest<'a> {
        pub const VT_CLIENT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_CLIENT_ROLE: flatbuffers::VOffsetT = 6;
        pub const VT_DATA_NODE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            HeartbeatRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args HeartbeatRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<HeartbeatRequest<'bldr>> {
            let mut builder = HeartbeatRequestBuilder::new(_fbb);
            if let Some(x) = args.data_node {
                builder.add_data_node(x);
            }
            if let Some(x) = args.client_id {
                builder.add_client_id(x);
            }
            builder.add_client_role(args.client_role);
            builder.finish()
        }

        pub fn unpack(&self) -> HeartbeatRequestT {
            let client_id = self.client_id().map(|x| x.to_string());
            let client_role = self.client_role();
            let data_node = self.data_node().map(|x| Box::new(x.unpack()));
            HeartbeatRequestT {
                client_id,
                client_role,
                data_node,
            }
        }

        #[inline]
        pub fn client_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(HeartbeatRequest::VT_CLIENT_ID, None)
            }
        }
        #[inline]
        pub fn client_role(&self) -> ClientRole {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ClientRole>(
                        HeartbeatRequest::VT_CLIENT_ROLE,
                        Some(ClientRole::CLIENT_ROLE_UNSPECIFIED),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn data_node(&self) -> Option<DataNode<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<DataNode>>(
                    HeartbeatRequest::VT_DATA_NODE,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for HeartbeatRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "client_id",
                    Self::VT_CLIENT_ID,
                    false,
                )?
                .visit_field::<ClientRole>("client_role", Self::VT_CLIENT_ROLE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<DataNode>>(
                    "data_node",
                    Self::VT_DATA_NODE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct HeartbeatRequestArgs<'a> {
        pub client_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub client_role: ClientRole,
        pub data_node: Option<flatbuffers::WIPOffset<DataNode<'a>>>,
    }
    impl<'a> Default for HeartbeatRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            HeartbeatRequestArgs {
                client_id: None,
                client_role: ClientRole::CLIENT_ROLE_UNSPECIFIED,
                data_node: None,
            }
        }
    }

    pub struct HeartbeatRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> HeartbeatRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_client_id(&mut self, client_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                HeartbeatRequest::VT_CLIENT_ID,
                client_id,
            );
        }
        #[inline]
        pub fn add_client_role(&mut self, client_role: ClientRole) {
            self.fbb_.push_slot::<ClientRole>(
                HeartbeatRequest::VT_CLIENT_ROLE,
                client_role,
                ClientRole::CLIENT_ROLE_UNSPECIFIED,
            );
        }
        #[inline]
        pub fn add_data_node(&mut self, data_node: flatbuffers::WIPOffset<DataNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<DataNode>>(
                    HeartbeatRequest::VT_DATA_NODE,
                    data_node,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> HeartbeatRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            HeartbeatRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<HeartbeatRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for HeartbeatRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("HeartbeatRequest");
            ds.field("client_id", &self.client_id());
            ds.field("client_role", &self.client_role());
            ds.field("data_node", &self.data_node());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct HeartbeatRequestT {
        pub client_id: Option<String>,
        pub client_role: ClientRole,
        pub data_node: Option<Box<DataNodeT>>,
    }
    impl Default for HeartbeatRequestT {
        fn default() -> Self {
            Self {
                client_id: None,
                client_role: ClientRole::CLIENT_ROLE_UNSPECIFIED,
                data_node: None,
            }
        }
    }
    impl HeartbeatRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<HeartbeatRequest<'b>> {
            let client_id = self.client_id.as_ref().map(|x| _fbb.create_string(x));
            let client_role = self.client_role;
            let data_node = self.data_node.as_ref().map(|x| x.pack(_fbb));
            HeartbeatRequest::create(
                _fbb,
                &HeartbeatRequestArgs {
                    client_id,
                    client_role,
                    data_node,
                },
            )
        }
    }
    pub enum HeartbeatResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct HeartbeatResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for HeartbeatResponse<'a> {
        type Inner = HeartbeatResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> HeartbeatResponse<'a> {
        pub const VT_CLIENT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_CLIENT_ROLE: flatbuffers::VOffsetT = 6;
        pub const VT_DATA_NODE: flatbuffers::VOffsetT = 8;
        pub const VT_STATUS: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            HeartbeatResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args HeartbeatResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<HeartbeatResponse<'bldr>> {
            let mut builder = HeartbeatResponseBuilder::new(_fbb);
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            if let Some(x) = args.data_node {
                builder.add_data_node(x);
            }
            if let Some(x) = args.client_id {
                builder.add_client_id(x);
            }
            builder.add_client_role(args.client_role);
            builder.finish()
        }

        pub fn unpack(&self) -> HeartbeatResponseT {
            let client_id = self.client_id().map(|x| x.to_string());
            let client_role = self.client_role();
            let data_node = self.data_node().map(|x| Box::new(x.unpack()));
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            HeartbeatResponseT {
                client_id,
                client_role,
                data_node,
                status,
            }
        }

        #[inline]
        pub fn client_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    HeartbeatResponse::VT_CLIENT_ID,
                    None,
                )
            }
        }
        #[inline]
        pub fn client_role(&self) -> ClientRole {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ClientRole>(
                        HeartbeatResponse::VT_CLIENT_ROLE,
                        Some(ClientRole::CLIENT_ROLE_UNSPECIFIED),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn data_node(&self) -> Option<DataNode<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<DataNode>>(
                    HeartbeatResponse::VT_DATA_NODE,
                    None,
                )
            }
        }
        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(HeartbeatResponse::VT_STATUS, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for HeartbeatResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "client_id",
                    Self::VT_CLIENT_ID,
                    false,
                )?
                .visit_field::<ClientRole>("client_role", Self::VT_CLIENT_ROLE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<DataNode>>(
                    "data_node",
                    Self::VT_DATA_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct HeartbeatResponseArgs<'a> {
        pub client_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub client_role: ClientRole,
        pub data_node: Option<flatbuffers::WIPOffset<DataNode<'a>>>,
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
    }
    impl<'a> Default for HeartbeatResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            HeartbeatResponseArgs {
                client_id: None,
                client_role: ClientRole::CLIENT_ROLE_UNSPECIFIED,
                data_node: None,
                status: None, // required field
            }
        }
    }

    pub struct HeartbeatResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> HeartbeatResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_client_id(&mut self, client_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                HeartbeatResponse::VT_CLIENT_ID,
                client_id,
            );
        }
        #[inline]
        pub fn add_client_role(&mut self, client_role: ClientRole) {
            self.fbb_.push_slot::<ClientRole>(
                HeartbeatResponse::VT_CLIENT_ROLE,
                client_role,
                ClientRole::CLIENT_ROLE_UNSPECIFIED,
            );
        }
        #[inline]
        pub fn add_data_node(&mut self, data_node: flatbuffers::WIPOffset<DataNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<DataNode>>(
                    HeartbeatResponse::VT_DATA_NODE,
                    data_node,
                );
        }
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    HeartbeatResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> HeartbeatResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            HeartbeatResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<HeartbeatResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, HeartbeatResponse::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for HeartbeatResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("HeartbeatResponse");
            ds.field("client_id", &self.client_id());
            ds.field("client_role", &self.client_role());
            ds.field("data_node", &self.data_node());
            ds.field("status", &self.status());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct HeartbeatResponseT {
        pub client_id: Option<String>,
        pub client_role: ClientRole,
        pub data_node: Option<Box<DataNodeT>>,
        pub status: Box<StatusT>,
    }
    impl Default for HeartbeatResponseT {
        fn default() -> Self {
            Self {
                client_id: None,
                client_role: ClientRole::CLIENT_ROLE_UNSPECIFIED,
                data_node: None,
                status: Default::default(),
            }
        }
    }
    impl HeartbeatResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<HeartbeatResponse<'b>> {
            let client_id = self.client_id.as_ref().map(|x| _fbb.create_string(x));
            let client_role = self.client_role;
            let data_node = self.data_node.as_ref().map(|x| x.pack(_fbb));
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            HeartbeatResponse::create(
                _fbb,
                &HeartbeatResponseArgs {
                    client_id,
                    client_role,
                    data_node,
                    status,
                },
            )
        }
    }
    pub enum IdAllocationRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct IdAllocationRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IdAllocationRequest<'a> {
        type Inner = IdAllocationRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> IdAllocationRequest<'a> {
        pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 4;
        pub const VT_HOST: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IdAllocationRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IdAllocationRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<IdAllocationRequest<'bldr>> {
            let mut builder = IdAllocationRequestBuilder::new(_fbb);
            if let Some(x) = args.host {
                builder.add_host(x);
            }
            builder.add_timeout_ms(args.timeout_ms);
            builder.finish()
        }

        pub fn unpack(&self) -> IdAllocationRequestT {
            let timeout_ms = self.timeout_ms();
            let host = {
                let x = self.host();
                x.to_string()
            };
            IdAllocationRequestT { timeout_ms, host }
        }

        #[inline]
        pub fn timeout_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(IdAllocationRequest::VT_TIMEOUT_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn host(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(IdAllocationRequest::VT_HOST, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for IdAllocationRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("host", Self::VT_HOST, true)?
                .finish();
            Ok(())
        }
    }
    pub struct IdAllocationRequestArgs<'a> {
        pub timeout_ms: i32,
        pub host: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for IdAllocationRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            IdAllocationRequestArgs {
                timeout_ms: 0,
                host: None, // required field
            }
        }
    }

    pub struct IdAllocationRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IdAllocationRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_timeout_ms(&mut self, timeout_ms: i32) {
            self.fbb_
                .push_slot::<i32>(IdAllocationRequest::VT_TIMEOUT_MS, timeout_ms, 0);
        }
        #[inline]
        pub fn add_host(&mut self, host: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IdAllocationRequest::VT_HOST, host);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> IdAllocationRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IdAllocationRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IdAllocationRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, IdAllocationRequest::VT_HOST, "host");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for IdAllocationRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("IdAllocationRequest");
            ds.field("timeout_ms", &self.timeout_ms());
            ds.field("host", &self.host());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct IdAllocationRequestT {
        pub timeout_ms: i32,
        pub host: String,
    }
    impl Default for IdAllocationRequestT {
        fn default() -> Self {
            Self {
                timeout_ms: 0,
                host: "".to_string(),
            }
        }
    }
    impl IdAllocationRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<IdAllocationRequest<'b>> {
            let timeout_ms = self.timeout_ms;
            let host = Some({
                let x = &self.host;
                _fbb.create_string(x)
            });
            IdAllocationRequest::create(_fbb, &IdAllocationRequestArgs { timeout_ms, host })
        }
    }
    pub enum IdAllocationResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct IdAllocationResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IdAllocationResponse<'a> {
        type Inner = IdAllocationResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> IdAllocationResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IdAllocationResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IdAllocationResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<IdAllocationResponse<'bldr>> {
            let mut builder = IdAllocationResponseBuilder::new(_fbb);
            builder.add_id(args.id);
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> IdAllocationResponseT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let id = self.id();
            IdAllocationResponseT { status, id }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(
                        IdAllocationResponse::VT_STATUS,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn id(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(IdAllocationResponse::VT_ID, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for IdAllocationResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<i32>("id", Self::VT_ID, false)?
                .finish();
            Ok(())
        }
    }
    pub struct IdAllocationResponseArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub id: i32,
    }
    impl<'a> Default for IdAllocationResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            IdAllocationResponseArgs {
                status: None, // required field
                id: 0,
            }
        }
    }

    pub struct IdAllocationResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IdAllocationResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    IdAllocationResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_id(&mut self, id: i32) {
            self.fbb_
                .push_slot::<i32>(IdAllocationResponse::VT_ID, id, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> IdAllocationResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IdAllocationResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IdAllocationResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, IdAllocationResponse::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for IdAllocationResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("IdAllocationResponse");
            ds.field("status", &self.status());
            ds.field("id", &self.id());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct IdAllocationResponseT {
        pub status: Box<StatusT>,
        pub id: i32,
    }
    impl Default for IdAllocationResponseT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                id: 0,
            }
        }
    }
    impl IdAllocationResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<IdAllocationResponse<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let id = self.id;
            IdAllocationResponse::create(_fbb, &IdAllocationResponseArgs { status, id })
        }
    }
    pub enum AppendRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AppendRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AppendRequest<'a> {
        type Inner = AppendRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AppendRequest<'a> {
        pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AppendRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AppendRequestArgs,
        ) -> flatbuffers::WIPOffset<AppendRequest<'bldr>> {
            let mut builder = AppendRequestBuilder::new(_fbb);
            builder.add_timeout_ms(args.timeout_ms);
            builder.finish()
        }

        pub fn unpack(&self) -> AppendRequestT {
            let timeout_ms = self.timeout_ms();
            AppendRequestT { timeout_ms }
        }

        #[inline]
        pub fn timeout_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(AppendRequest::VT_TIMEOUT_MS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for AppendRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AppendRequestArgs {
        pub timeout_ms: i32,
    }
    impl<'a> Default for AppendRequestArgs {
        #[inline]
        fn default() -> Self {
            AppendRequestArgs { timeout_ms: 0 }
        }
    }

    pub struct AppendRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AppendRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_timeout_ms(&mut self, timeout_ms: i32) {
            self.fbb_
                .push_slot::<i32>(AppendRequest::VT_TIMEOUT_MS, timeout_ms, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> AppendRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AppendRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AppendRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AppendRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AppendRequest");
            ds.field("timeout_ms", &self.timeout_ms());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AppendRequestT {
        pub timeout_ms: i32,
    }
    impl Default for AppendRequestT {
        fn default() -> Self {
            Self { timeout_ms: 0 }
        }
    }
    impl AppendRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<AppendRequest<'b>> {
            let timeout_ms = self.timeout_ms;
            AppendRequest::create(_fbb, &AppendRequestArgs { timeout_ms })
        }
    }
    pub enum AppendResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AppendResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AppendResponse<'a> {
        type Inner = AppendResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AppendResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_ENTRIES: flatbuffers::VOffsetT = 6;
        pub const VT_THROTTLE_TIME_MS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AppendResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AppendResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<AppendResponse<'bldr>> {
            let mut builder = AppendResponseBuilder::new(_fbb);
            builder.add_throttle_time_ms(args.throttle_time_ms);
            if let Some(x) = args.entries {
                builder.add_entries(x);
            }
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> AppendResponseT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let entries = self
                .entries()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            let throttle_time_ms = self.throttle_time_ms();
            AppendResponseT {
                status,
                entries,
                throttle_time_ms,
            }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(AppendResponse::VT_STATUS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn entries(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AppendResultEntry<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AppendResultEntry>>,
                >>(AppendResponse::VT_ENTRIES, None)
            }
        }
        #[inline]
        pub fn throttle_time_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(AppendResponse::VT_THROTTLE_TIME_MS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for AppendResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AppendResultEntry>>,
                >>("entries", Self::VT_ENTRIES, false)?
                .visit_field::<i32>("throttle_time_ms", Self::VT_THROTTLE_TIME_MS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AppendResponseArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub entries: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AppendResultEntry<'a>>>,
            >,
        >,
        pub throttle_time_ms: i32,
    }
    impl<'a> Default for AppendResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            AppendResponseArgs {
                status: None, // required field
                entries: None,
                throttle_time_ms: 0,
            }
        }
    }

    pub struct AppendResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AppendResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    AppendResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_entries(
            &mut self,
            entries: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AppendResultEntry<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AppendResponse::VT_ENTRIES, entries);
        }
        #[inline]
        pub fn add_throttle_time_ms(&mut self, throttle_time_ms: i32) {
            self.fbb_
                .push_slot::<i32>(AppendResponse::VT_THROTTLE_TIME_MS, throttle_time_ms, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> AppendResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AppendResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AppendResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, AppendResponse::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AppendResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AppendResponse");
            ds.field("status", &self.status());
            ds.field("entries", &self.entries());
            ds.field("throttle_time_ms", &self.throttle_time_ms());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AppendResponseT {
        pub status: Box<StatusT>,
        pub entries: Option<Vec<AppendResultEntryT>>,
        pub throttle_time_ms: i32,
    }
    impl Default for AppendResponseT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                entries: None,
                throttle_time_ms: 0,
            }
        }
    }
    impl AppendResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<AppendResponse<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let entries = self.entries.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let throttle_time_ms = self.throttle_time_ms;
            AppendResponse::create(
                _fbb,
                &AppendResponseArgs {
                    status,
                    entries,
                    throttle_time_ms,
                },
            )
        }
    }
    pub enum AppendResultEntryOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AppendResultEntry<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AppendResultEntry<'a> {
        type Inner = AppendResultEntry<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AppendResultEntry<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_TIMESTAMP_MS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AppendResultEntry { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AppendResultEntryArgs<'args>,
        ) -> flatbuffers::WIPOffset<AppendResultEntry<'bldr>> {
            let mut builder = AppendResultEntryBuilder::new(_fbb);
            builder.add_timestamp_ms(args.timestamp_ms);
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> AppendResultEntryT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let timestamp_ms = self.timestamp_ms();
            AppendResultEntryT {
                status,
                timestamp_ms,
            }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(AppendResultEntry::VT_STATUS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp_ms(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(AppendResultEntry::VT_TIMESTAMP_MS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for AppendResultEntry<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<i64>("timestamp_ms", Self::VT_TIMESTAMP_MS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AppendResultEntryArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub timestamp_ms: i64,
    }
    impl<'a> Default for AppendResultEntryArgs<'a> {
        #[inline]
        fn default() -> Self {
            AppendResultEntryArgs {
                status: None, // required field
                timestamp_ms: 0,
            }
        }
    }

    pub struct AppendResultEntryBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AppendResultEntryBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    AppendResultEntry::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_timestamp_ms(&mut self, timestamp_ms: i64) {
            self.fbb_
                .push_slot::<i64>(AppendResultEntry::VT_TIMESTAMP_MS, timestamp_ms, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> AppendResultEntryBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AppendResultEntryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AppendResultEntry<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, AppendResultEntry::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AppendResultEntry<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AppendResultEntry");
            ds.field("status", &self.status());
            ds.field("timestamp_ms", &self.timestamp_ms());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AppendResultEntryT {
        pub status: Box<StatusT>,
        pub timestamp_ms: i64,
    }
    impl Default for AppendResultEntryT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                timestamp_ms: 0,
            }
        }
    }
    impl AppendResultEntryT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<AppendResultEntry<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let timestamp_ms = self.timestamp_ms;
            AppendResultEntry::create(
                _fbb,
                &AppendResultEntryArgs {
                    status,
                    timestamp_ms,
                },
            )
        }
    }
    pub enum FetchRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FetchRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FetchRequest<'a> {
        type Inner = FetchRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> FetchRequest<'a> {
        pub const VT_MAX_WAIT_MS: flatbuffers::VOffsetT = 4;
        pub const VT_MIN_BYTES: flatbuffers::VOffsetT = 6;
        pub const VT_ENTRIES: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FetchRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FetchRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<FetchRequest<'bldr>> {
            let mut builder = FetchRequestBuilder::new(_fbb);
            if let Some(x) = args.entries {
                builder.add_entries(x);
            }
            builder.add_min_bytes(args.min_bytes);
            builder.add_max_wait_ms(args.max_wait_ms);
            builder.finish()
        }

        pub fn unpack(&self) -> FetchRequestT {
            let max_wait_ms = self.max_wait_ms();
            let min_bytes = self.min_bytes();
            let entries = self
                .entries()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            FetchRequestT {
                max_wait_ms,
                min_bytes,
                entries,
            }
        }

        #[inline]
        pub fn max_wait_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(FetchRequest::VT_MAX_WAIT_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn min_bytes(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(FetchRequest::VT_MIN_BYTES, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn entries(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FetchEntry<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FetchEntry>>,
                >>(FetchRequest::VT_ENTRIES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for FetchRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("max_wait_ms", Self::VT_MAX_WAIT_MS, false)?
                .visit_field::<i32>("min_bytes", Self::VT_MIN_BYTES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FetchEntry>>,
                >>("entries", Self::VT_ENTRIES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FetchRequestArgs<'a> {
        pub max_wait_ms: i32,
        pub min_bytes: i32,
        pub entries: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FetchEntry<'a>>>,
            >,
        >,
    }
    impl<'a> Default for FetchRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            FetchRequestArgs {
                max_wait_ms: 0,
                min_bytes: 0,
                entries: None,
            }
        }
    }

    pub struct FetchRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FetchRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_max_wait_ms(&mut self, max_wait_ms: i32) {
            self.fbb_
                .push_slot::<i32>(FetchRequest::VT_MAX_WAIT_MS, max_wait_ms, 0);
        }
        #[inline]
        pub fn add_min_bytes(&mut self, min_bytes: i32) {
            self.fbb_
                .push_slot::<i32>(FetchRequest::VT_MIN_BYTES, min_bytes, 0);
        }
        #[inline]
        pub fn add_entries(
            &mut self,
            entries: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FetchEntry<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchRequest::VT_ENTRIES, entries);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FetchRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FetchRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FetchRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for FetchRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("FetchRequest");
            ds.field("max_wait_ms", &self.max_wait_ms());
            ds.field("min_bytes", &self.min_bytes());
            ds.field("entries", &self.entries());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct FetchRequestT {
        pub max_wait_ms: i32,
        pub min_bytes: i32,
        pub entries: Option<Vec<FetchEntryT>>,
    }
    impl Default for FetchRequestT {
        fn default() -> Self {
            Self {
                max_wait_ms: 0,
                min_bytes: 0,
                entries: None,
            }
        }
    }
    impl FetchRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<FetchRequest<'b>> {
            let max_wait_ms = self.max_wait_ms;
            let min_bytes = self.min_bytes;
            let entries = self.entries.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            FetchRequest::create(
                _fbb,
                &FetchRequestArgs {
                    max_wait_ms,
                    min_bytes,
                    entries,
                },
            )
        }
    }
    pub enum FetchEntryOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FetchEntry<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FetchEntry<'a> {
        type Inner = FetchEntry<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> FetchEntry<'a> {
        pub const VT_RANGE: flatbuffers::VOffsetT = 4;
        pub const VT_FETCH_OFFSET: flatbuffers::VOffsetT = 6;
        pub const VT_END_OFFSET: flatbuffers::VOffsetT = 8;
        pub const VT_BATCH_MAX_BYTES: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FetchEntry { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FetchEntryArgs<'args>,
        ) -> flatbuffers::WIPOffset<FetchEntry<'bldr>> {
            let mut builder = FetchEntryBuilder::new(_fbb);
            builder.add_end_offset(args.end_offset);
            builder.add_fetch_offset(args.fetch_offset);
            builder.add_batch_max_bytes(args.batch_max_bytes);
            if let Some(x) = args.range {
                builder.add_range(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> FetchEntryT {
            let range = {
                let x = self.range();
                Box::new(x.unpack())
            };
            let fetch_offset = self.fetch_offset();
            let end_offset = self.end_offset();
            let batch_max_bytes = self.batch_max_bytes();
            FetchEntryT {
                range,
                fetch_offset,
                end_offset,
                batch_max_bytes,
            }
        }

        #[inline]
        pub fn range(&self) -> Range<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Range>>(FetchEntry::VT_RANGE, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn fetch_offset(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(FetchEntry::VT_FETCH_OFFSET, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn end_offset(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(FetchEntry::VT_END_OFFSET, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn batch_max_bytes(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(FetchEntry::VT_BATCH_MAX_BYTES, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for FetchEntry<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Range>>("range", Self::VT_RANGE, true)?
                .visit_field::<i64>("fetch_offset", Self::VT_FETCH_OFFSET, false)?
                .visit_field::<i64>("end_offset", Self::VT_END_OFFSET, false)?
                .visit_field::<i32>("batch_max_bytes", Self::VT_BATCH_MAX_BYTES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FetchEntryArgs<'a> {
        pub range: Option<flatbuffers::WIPOffset<Range<'a>>>,
        pub fetch_offset: i64,
        pub end_offset: i64,
        pub batch_max_bytes: i32,
    }
    impl<'a> Default for FetchEntryArgs<'a> {
        #[inline]
        fn default() -> Self {
            FetchEntryArgs {
                range: None, // required field
                fetch_offset: 0,
                end_offset: 0,
                batch_max_bytes: 0,
            }
        }
    }

    pub struct FetchEntryBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FetchEntryBuilder<'a, 'b> {
        #[inline]
        pub fn add_range(&mut self, range: flatbuffers::WIPOffset<Range<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Range>>(FetchEntry::VT_RANGE, range);
        }
        #[inline]
        pub fn add_fetch_offset(&mut self, fetch_offset: i64) {
            self.fbb_
                .push_slot::<i64>(FetchEntry::VT_FETCH_OFFSET, fetch_offset, 0);
        }
        #[inline]
        pub fn add_end_offset(&mut self, end_offset: i64) {
            self.fbb_
                .push_slot::<i64>(FetchEntry::VT_END_OFFSET, end_offset, 0);
        }
        #[inline]
        pub fn add_batch_max_bytes(&mut self, batch_max_bytes: i32) {
            self.fbb_
                .push_slot::<i32>(FetchEntry::VT_BATCH_MAX_BYTES, batch_max_bytes, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FetchEntryBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FetchEntryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FetchEntry<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, FetchEntry::VT_RANGE, "range");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for FetchEntry<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("FetchEntry");
            ds.field("range", &self.range());
            ds.field("fetch_offset", &self.fetch_offset());
            ds.field("end_offset", &self.end_offset());
            ds.field("batch_max_bytes", &self.batch_max_bytes());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct FetchEntryT {
        pub range: Box<RangeT>,
        pub fetch_offset: i64,
        pub end_offset: i64,
        pub batch_max_bytes: i32,
    }
    impl Default for FetchEntryT {
        fn default() -> Self {
            Self {
                range: Default::default(),
                fetch_offset: 0,
                end_offset: 0,
                batch_max_bytes: 0,
            }
        }
    }
    impl FetchEntryT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<FetchEntry<'b>> {
            let range = Some({
                let x = &self.range;
                x.pack(_fbb)
            });
            let fetch_offset = self.fetch_offset;
            let end_offset = self.end_offset;
            let batch_max_bytes = self.batch_max_bytes;
            FetchEntry::create(
                _fbb,
                &FetchEntryArgs {
                    range,
                    fetch_offset,
                    end_offset,
                    batch_max_bytes,
                },
            )
        }
    }
    pub enum FetchResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FetchResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FetchResponse<'a> {
        type Inner = FetchResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> FetchResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_ENTRIES: flatbuffers::VOffsetT = 6;
        pub const VT_THROTTLE_TIME_MS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FetchResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FetchResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<FetchResponse<'bldr>> {
            let mut builder = FetchResponseBuilder::new(_fbb);
            builder.add_throttle_time_ms(args.throttle_time_ms);
            if let Some(x) = args.entries {
                builder.add_entries(x);
            }
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> FetchResponseT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let entries = self
                .entries()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            let throttle_time_ms = self.throttle_time_ms();
            FetchResponseT {
                status,
                entries,
                throttle_time_ms,
            }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(FetchResponse::VT_STATUS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn entries(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FetchResultEntry<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FetchResultEntry>>,
                >>(FetchResponse::VT_ENTRIES, None)
            }
        }
        #[inline]
        pub fn throttle_time_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(FetchResponse::VT_THROTTLE_TIME_MS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for FetchResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FetchResultEntry>>,
                >>("entries", Self::VT_ENTRIES, false)?
                .visit_field::<i32>("throttle_time_ms", Self::VT_THROTTLE_TIME_MS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FetchResponseArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub entries: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FetchResultEntry<'a>>>,
            >,
        >,
        pub throttle_time_ms: i32,
    }
    impl<'a> Default for FetchResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            FetchResponseArgs {
                status: None, // required field
                entries: None,
                throttle_time_ms: 0,
            }
        }
    }

    pub struct FetchResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FetchResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    FetchResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_entries(
            &mut self,
            entries: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FetchResultEntry<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchResponse::VT_ENTRIES, entries);
        }
        #[inline]
        pub fn add_throttle_time_ms(&mut self, throttle_time_ms: i32) {
            self.fbb_
                .push_slot::<i32>(FetchResponse::VT_THROTTLE_TIME_MS, throttle_time_ms, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FetchResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FetchResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FetchResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, FetchResponse::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for FetchResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("FetchResponse");
            ds.field("status", &self.status());
            ds.field("entries", &self.entries());
            ds.field("throttle_time_ms", &self.throttle_time_ms());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct FetchResponseT {
        pub status: Box<StatusT>,
        pub entries: Option<Vec<FetchResultEntryT>>,
        pub throttle_time_ms: i32,
    }
    impl Default for FetchResponseT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                entries: None,
                throttle_time_ms: 0,
            }
        }
    }
    impl FetchResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<FetchResponse<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let entries = self.entries.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let throttle_time_ms = self.throttle_time_ms;
            FetchResponse::create(
                _fbb,
                &FetchResponseArgs {
                    status,
                    entries,
                    throttle_time_ms,
                },
            )
        }
    }
    pub enum FetchResultEntryOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FetchResultEntry<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FetchResultEntry<'a> {
        type Inner = FetchResultEntry<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> FetchResultEntry<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_STREAM_ID: flatbuffers::VOffsetT = 6;
        pub const VT_BATCH_COUNT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FetchResultEntry { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FetchResultEntryArgs<'args>,
        ) -> flatbuffers::WIPOffset<FetchResultEntry<'bldr>> {
            let mut builder = FetchResultEntryBuilder::new(_fbb);
            builder.add_stream_id(args.stream_id);
            builder.add_batch_count(args.batch_count);
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> FetchResultEntryT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let stream_id = self.stream_id();
            let batch_count = self.batch_count();
            FetchResultEntryT {
                status,
                stream_id,
                batch_count,
            }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(FetchResultEntry::VT_STATUS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn stream_id(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(FetchResultEntry::VT_STREAM_ID, Some(-1))
                    .unwrap()
            }
        }
        #[inline]
        pub fn batch_count(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(FetchResultEntry::VT_BATCH_COUNT, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for FetchResultEntry<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<i64>("stream_id", Self::VT_STREAM_ID, false)?
                .visit_field::<i32>("batch_count", Self::VT_BATCH_COUNT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FetchResultEntryArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub stream_id: i64,
        pub batch_count: i32,
    }
    impl<'a> Default for FetchResultEntryArgs<'a> {
        #[inline]
        fn default() -> Self {
            FetchResultEntryArgs {
                status: None, // required field
                stream_id: -1,
                batch_count: 0,
            }
        }
    }

    pub struct FetchResultEntryBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FetchResultEntryBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    FetchResultEntry::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_stream_id(&mut self, stream_id: i64) {
            self.fbb_
                .push_slot::<i64>(FetchResultEntry::VT_STREAM_ID, stream_id, -1);
        }
        #[inline]
        pub fn add_batch_count(&mut self, batch_count: i32) {
            self.fbb_
                .push_slot::<i32>(FetchResultEntry::VT_BATCH_COUNT, batch_count, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FetchResultEntryBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FetchResultEntryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FetchResultEntry<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, FetchResultEntry::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for FetchResultEntry<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("FetchResultEntry");
            ds.field("status", &self.status());
            ds.field("stream_id", &self.stream_id());
            ds.field("batch_count", &self.batch_count());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct FetchResultEntryT {
        pub status: Box<StatusT>,
        pub stream_id: i64,
        pub batch_count: i32,
    }
    impl Default for FetchResultEntryT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                stream_id: -1,
                batch_count: 0,
            }
        }
    }
    impl FetchResultEntryT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<FetchResultEntry<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let stream_id = self.stream_id;
            let batch_count = self.batch_count;
            FetchResultEntry::create(
                _fbb,
                &FetchResultEntryArgs {
                    status,
                    stream_id,
                    batch_count,
                },
            )
        }
    }
    pub enum ListRangeCriteriaOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ListRangeCriteria<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ListRangeCriteria<'a> {
        type Inner = ListRangeCriteria<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ListRangeCriteria<'a> {
        pub const VT_NODE_ID: flatbuffers::VOffsetT = 4;
        pub const VT_STREAM_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ListRangeCriteria { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ListRangeCriteriaArgs,
        ) -> flatbuffers::WIPOffset<ListRangeCriteria<'bldr>> {
            let mut builder = ListRangeCriteriaBuilder::new(_fbb);
            builder.add_stream_id(args.stream_id);
            builder.add_node_id(args.node_id);
            builder.finish()
        }

        pub fn unpack(&self) -> ListRangeCriteriaT {
            let node_id = self.node_id();
            let stream_id = self.stream_id();
            ListRangeCriteriaT { node_id, stream_id }
        }

        #[inline]
        pub fn node_id(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(ListRangeCriteria::VT_NODE_ID, Some(-1))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stream_id(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(ListRangeCriteria::VT_STREAM_ID, Some(-1))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ListRangeCriteria<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("node_id", Self::VT_NODE_ID, false)?
                .visit_field::<i64>("stream_id", Self::VT_STREAM_ID, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ListRangeCriteriaArgs {
        pub node_id: i32,
        pub stream_id: i64,
    }
    impl<'a> Default for ListRangeCriteriaArgs {
        #[inline]
        fn default() -> Self {
            ListRangeCriteriaArgs {
                node_id: -1,
                stream_id: -1,
            }
        }
    }

    pub struct ListRangeCriteriaBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ListRangeCriteriaBuilder<'a, 'b> {
        #[inline]
        pub fn add_node_id(&mut self, node_id: i32) {
            self.fbb_
                .push_slot::<i32>(ListRangeCriteria::VT_NODE_ID, node_id, -1);
        }
        #[inline]
        pub fn add_stream_id(&mut self, stream_id: i64) {
            self.fbb_
                .push_slot::<i64>(ListRangeCriteria::VT_STREAM_ID, stream_id, -1);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ListRangeCriteriaBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ListRangeCriteriaBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ListRangeCriteria<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ListRangeCriteria<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ListRangeCriteria");
            ds.field("node_id", &self.node_id());
            ds.field("stream_id", &self.stream_id());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ListRangeCriteriaT {
        pub node_id: i32,
        pub stream_id: i64,
    }
    impl Default for ListRangeCriteriaT {
        fn default() -> Self {
            Self {
                node_id: -1,
                stream_id: -1,
            }
        }
    }
    impl ListRangeCriteriaT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<ListRangeCriteria<'b>> {
            let node_id = self.node_id;
            let stream_id = self.stream_id;
            ListRangeCriteria::create(_fbb, &ListRangeCriteriaArgs { node_id, stream_id })
        }
    }
    pub enum DataNodeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DataNode<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DataNode<'a> {
        type Inner = DataNode<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DataNode<'a> {
        pub const VT_NODE_ID: flatbuffers::VOffsetT = 4;
        pub const VT_ADVERTISE_ADDR: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DataNode { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DataNodeArgs<'args>,
        ) -> flatbuffers::WIPOffset<DataNode<'bldr>> {
            let mut builder = DataNodeBuilder::new(_fbb);
            if let Some(x) = args.advertise_addr {
                builder.add_advertise_addr(x);
            }
            builder.add_node_id(args.node_id);
            builder.finish()
        }

        pub fn unpack(&self) -> DataNodeT {
            let node_id = self.node_id();
            let advertise_addr = {
                let x = self.advertise_addr();
                x.to_string()
            };
            DataNodeT {
                node_id,
                advertise_addr,
            }
        }

        #[inline]
        pub fn node_id(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DataNode::VT_NODE_ID, Some(-1))
                    .unwrap()
            }
        }
        #[inline]
        pub fn advertise_addr(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(DataNode::VT_ADVERTISE_ADDR, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DataNode<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("node_id", Self::VT_NODE_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "advertise_addr",
                    Self::VT_ADVERTISE_ADDR,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct DataNodeArgs<'a> {
        pub node_id: i32,
        pub advertise_addr: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for DataNodeArgs<'a> {
        #[inline]
        fn default() -> Self {
            DataNodeArgs {
                node_id: -1,
                advertise_addr: None, // required field
            }
        }
    }

    pub struct DataNodeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DataNodeBuilder<'a, 'b> {
        #[inline]
        pub fn add_node_id(&mut self, node_id: i32) {
            self.fbb_
                .push_slot::<i32>(DataNode::VT_NODE_ID, node_id, -1);
        }
        #[inline]
        pub fn add_advertise_addr(&mut self, advertise_addr: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                DataNode::VT_ADVERTISE_ADDR,
                advertise_addr,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DataNodeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DataNodeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DataNode<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, DataNode::VT_ADVERTISE_ADDR, "advertise_addr");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DataNode<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DataNode");
            ds.field("node_id", &self.node_id());
            ds.field("advertise_addr", &self.advertise_addr());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct DataNodeT {
        pub node_id: i32,
        pub advertise_addr: String,
    }
    impl Default for DataNodeT {
        fn default() -> Self {
            Self {
                node_id: -1,
                advertise_addr: "".to_string(),
            }
        }
    }
    impl DataNodeT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<DataNode<'b>> {
            let node_id = self.node_id;
            let advertise_addr = Some({
                let x = &self.advertise_addr;
                _fbb.create_string(x)
            });
            DataNode::create(
                _fbb,
                &DataNodeArgs {
                    node_id,
                    advertise_addr,
                },
            )
        }
    }
    pub enum ListRangeRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ListRangeRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ListRangeRequest<'a> {
        type Inner = ListRangeRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ListRangeRequest<'a> {
        pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 4;
        pub const VT_CRITERIA: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ListRangeRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ListRangeRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<ListRangeRequest<'bldr>> {
            let mut builder = ListRangeRequestBuilder::new(_fbb);
            if let Some(x) = args.criteria {
                builder.add_criteria(x);
            }
            builder.add_timeout_ms(args.timeout_ms);
            builder.finish()
        }

        pub fn unpack(&self) -> ListRangeRequestT {
            let timeout_ms = self.timeout_ms();
            let criteria = {
                let x = self.criteria();
                Box::new(x.unpack())
            };
            ListRangeRequestT {
                timeout_ms,
                criteria,
            }
        }

        #[inline]
        pub fn timeout_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(ListRangeRequest::VT_TIMEOUT_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn criteria(&self) -> ListRangeCriteria<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<ListRangeCriteria>>(
                        ListRangeRequest::VT_CRITERIA,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ListRangeRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<ListRangeCriteria>>(
                    "criteria",
                    Self::VT_CRITERIA,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ListRangeRequestArgs<'a> {
        pub timeout_ms: i32,
        pub criteria: Option<flatbuffers::WIPOffset<ListRangeCriteria<'a>>>,
    }
    impl<'a> Default for ListRangeRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            ListRangeRequestArgs {
                timeout_ms: 0,
                criteria: None, // required field
            }
        }
    }

    pub struct ListRangeRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ListRangeRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_timeout_ms(&mut self, timeout_ms: i32) {
            self.fbb_
                .push_slot::<i32>(ListRangeRequest::VT_TIMEOUT_MS, timeout_ms, 0);
        }
        #[inline]
        pub fn add_criteria(&mut self, criteria: flatbuffers::WIPOffset<ListRangeCriteria<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<ListRangeCriteria>>(
                    ListRangeRequest::VT_CRITERIA,
                    criteria,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ListRangeRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ListRangeRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ListRangeRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, ListRangeRequest::VT_CRITERIA, "criteria");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ListRangeRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ListRangeRequest");
            ds.field("timeout_ms", &self.timeout_ms());
            ds.field("criteria", &self.criteria());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ListRangeRequestT {
        pub timeout_ms: i32,
        pub criteria: Box<ListRangeCriteriaT>,
    }
    impl Default for ListRangeRequestT {
        fn default() -> Self {
            Self {
                timeout_ms: 0,
                criteria: Default::default(),
            }
        }
    }
    impl ListRangeRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<ListRangeRequest<'b>> {
            let timeout_ms = self.timeout_ms;
            let criteria = Some({
                let x = &self.criteria;
                x.pack(_fbb)
            });
            ListRangeRequest::create(
                _fbb,
                &ListRangeRequestArgs {
                    timeout_ms,
                    criteria,
                },
            )
        }
    }
    pub enum ListRangeResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ListRangeResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ListRangeResponse<'a> {
        type Inner = ListRangeResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ListRangeResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_THROTTLE_TIME_MS: flatbuffers::VOffsetT = 6;
        pub const VT_RANGES: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ListRangeResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ListRangeResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<ListRangeResponse<'bldr>> {
            let mut builder = ListRangeResponseBuilder::new(_fbb);
            if let Some(x) = args.ranges {
                builder.add_ranges(x);
            }
            builder.add_throttle_time_ms(args.throttle_time_ms);
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ListRangeResponseT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let throttle_time_ms = self.throttle_time_ms();
            let ranges = {
                let x = self.ranges();
                x.iter().map(|t| t.unpack()).collect()
            };
            ListRangeResponseT {
                status,
                throttle_time_ms,
                ranges,
            }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(ListRangeResponse::VT_STATUS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn throttle_time_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(ListRangeResponse::VT_THROTTLE_TIME_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn ranges(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Range<'a>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Range>>,
                    >>(ListRangeResponse::VT_RANGES, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ListRangeResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<i32>("throttle_time_ms", Self::VT_THROTTLE_TIME_MS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Range>>,
                >>("ranges", Self::VT_RANGES, true)?
                .finish();
            Ok(())
        }
    }
    pub struct ListRangeResponseArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub throttle_time_ms: i32,
        pub ranges: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Range<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ListRangeResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            ListRangeResponseArgs {
                status: None, // required field
                throttle_time_ms: 0,
                ranges: None, // required field
            }
        }
    }

    pub struct ListRangeResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ListRangeResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    ListRangeResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_throttle_time_ms(&mut self, throttle_time_ms: i32) {
            self.fbb_
                .push_slot::<i32>(ListRangeResponse::VT_THROTTLE_TIME_MS, throttle_time_ms, 0);
        }
        #[inline]
        pub fn add_ranges(
            &mut self,
            ranges: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Range<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ListRangeResponse::VT_RANGES,
                ranges,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ListRangeResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ListRangeResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ListRangeResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, ListRangeResponse::VT_STATUS, "status");
            self.fbb_
                .required(o, ListRangeResponse::VT_RANGES, "ranges");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ListRangeResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ListRangeResponse");
            ds.field("status", &self.status());
            ds.field("throttle_time_ms", &self.throttle_time_ms());
            ds.field("ranges", &self.ranges());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ListRangeResponseT {
        pub status: Box<StatusT>,
        pub throttle_time_ms: i32,
        pub ranges: Vec<RangeT>,
    }
    impl Default for ListRangeResponseT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                throttle_time_ms: 0,
                ranges: Default::default(),
            }
        }
    }
    impl ListRangeResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<ListRangeResponse<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let throttle_time_ms = self.throttle_time_ms;
            let ranges = Some({
                let x = &self.ranges;
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            ListRangeResponse::create(
                _fbb,
                &ListRangeResponseArgs {
                    status,
                    throttle_time_ms,
                    ranges,
                },
            )
        }
    }
    pub enum RangeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Range<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Range<'a> {
        type Inner = Range<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Range<'a> {
        pub const VT_STREAM_ID: flatbuffers::VOffsetT = 4;
        pub const VT_EPOCH: flatbuffers::VOffsetT = 6;
        pub const VT_INDEX: flatbuffers::VOffsetT = 8;
        pub const VT_START: flatbuffers::VOffsetT = 10;
        pub const VT_END: flatbuffers::VOffsetT = 12;
        pub const VT_NODES: flatbuffers::VOffsetT = 14;
        pub const VT_REPLICA_COUNT: flatbuffers::VOffsetT = 16;
        pub const VT_ACK_COUNT: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Range { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RangeArgs<'args>,
        ) -> flatbuffers::WIPOffset<Range<'bldr>> {
            let mut builder = RangeBuilder::new(_fbb);
            builder.add_end(args.end);
            builder.add_start(args.start);
            builder.add_epoch(args.epoch);
            builder.add_stream_id(args.stream_id);
            if let Some(x) = args.nodes {
                builder.add_nodes(x);
            }
            builder.add_index(args.index);
            builder.add_ack_count(args.ack_count);
            builder.add_replica_count(args.replica_count);
            builder.finish()
        }

        pub fn unpack(&self) -> RangeT {
            let stream_id = self.stream_id();
            let epoch = self.epoch();
            let index = self.index();
            let start = self.start();
            let end = self.end();
            let nodes = self.nodes().map(|x| x.iter().map(|t| t.unpack()).collect());
            let replica_count = self.replica_count();
            let ack_count = self.ack_count();
            RangeT {
                stream_id,
                epoch,
                index,
                start,
                end,
                nodes,
                replica_count,
                ack_count,
            }
        }

        #[inline]
        pub fn stream_id(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i64>(Range::VT_STREAM_ID, Some(-1)).unwrap() }
        }
        #[inline]
        pub fn epoch(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i64>(Range::VT_EPOCH, Some(-1)).unwrap() }
        }
        #[inline]
        pub fn index(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i32>(Range::VT_INDEX, Some(-1)).unwrap() }
        }
        #[inline]
        pub fn start(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i64>(Range::VT_START, Some(-1)).unwrap() }
        }
        #[inline]
        pub fn end(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i64>(Range::VT_END, Some(-1)).unwrap() }
        }
        #[inline]
        pub fn nodes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataNode<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataNode>>,
                >>(Range::VT_NODES, None)
            }
        }
        #[inline]
        pub fn replica_count(&self) -> i8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i8>(Range::VT_REPLICA_COUNT, Some(-1))
                    .unwrap()
            }
        }
        #[inline]
        pub fn ack_count(&self) -> i8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i8>(Range::VT_ACK_COUNT, Some(-1)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Range<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i64>("stream_id", Self::VT_STREAM_ID, false)?
                .visit_field::<i64>("epoch", Self::VT_EPOCH, false)?
                .visit_field::<i32>("index", Self::VT_INDEX, false)?
                .visit_field::<i64>("start", Self::VT_START, false)?
                .visit_field::<i64>("end", Self::VT_END, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DataNode>>,
                >>("nodes", Self::VT_NODES, false)?
                .visit_field::<i8>("replica_count", Self::VT_REPLICA_COUNT, false)?
                .visit_field::<i8>("ack_count", Self::VT_ACK_COUNT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RangeArgs<'a> {
        pub stream_id: i64,
        pub epoch: i64,
        pub index: i32,
        pub start: i64,
        pub end: i64,
        pub nodes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataNode<'a>>>,
            >,
        >,
        pub replica_count: i8,
        pub ack_count: i8,
    }
    impl<'a> Default for RangeArgs<'a> {
        #[inline]
        fn default() -> Self {
            RangeArgs {
                stream_id: -1,
                epoch: -1,
                index: -1,
                start: -1,
                end: -1,
                nodes: None,
                replica_count: -1,
                ack_count: -1,
            }
        }
    }

    pub struct RangeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RangeBuilder<'a, 'b> {
        #[inline]
        pub fn add_stream_id(&mut self, stream_id: i64) {
            self.fbb_
                .push_slot::<i64>(Range::VT_STREAM_ID, stream_id, -1);
        }
        #[inline]
        pub fn add_epoch(&mut self, epoch: i64) {
            self.fbb_.push_slot::<i64>(Range::VT_EPOCH, epoch, -1);
        }
        #[inline]
        pub fn add_index(&mut self, index: i32) {
            self.fbb_.push_slot::<i32>(Range::VT_INDEX, index, -1);
        }
        #[inline]
        pub fn add_start(&mut self, start: i64) {
            self.fbb_.push_slot::<i64>(Range::VT_START, start, -1);
        }
        #[inline]
        pub fn add_end(&mut self, end: i64) {
            self.fbb_.push_slot::<i64>(Range::VT_END, end, -1);
        }
        #[inline]
        pub fn add_nodes(
            &mut self,
            nodes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DataNode<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Range::VT_NODES, nodes);
        }
        #[inline]
        pub fn add_replica_count(&mut self, replica_count: i8) {
            self.fbb_
                .push_slot::<i8>(Range::VT_REPLICA_COUNT, replica_count, -1);
        }
        #[inline]
        pub fn add_ack_count(&mut self, ack_count: i8) {
            self.fbb_
                .push_slot::<i8>(Range::VT_ACK_COUNT, ack_count, -1);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RangeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RangeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Range<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Range<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Range");
            ds.field("stream_id", &self.stream_id());
            ds.field("epoch", &self.epoch());
            ds.field("index", &self.index());
            ds.field("start", &self.start());
            ds.field("end", &self.end());
            ds.field("nodes", &self.nodes());
            ds.field("replica_count", &self.replica_count());
            ds.field("ack_count", &self.ack_count());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct RangeT {
        pub stream_id: i64,
        pub epoch: i64,
        pub index: i32,
        pub start: i64,
        pub end: i64,
        pub nodes: Option<Vec<DataNodeT>>,
        pub replica_count: i8,
        pub ack_count: i8,
    }
    impl Default for RangeT {
        fn default() -> Self {
            Self {
                stream_id: -1,
                epoch: -1,
                index: -1,
                start: -1,
                end: -1,
                nodes: None,
                replica_count: -1,
                ack_count: -1,
            }
        }
    }
    impl RangeT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Range<'b>> {
            let stream_id = self.stream_id;
            let epoch = self.epoch;
            let index = self.index;
            let start = self.start;
            let end = self.end;
            let nodes = self.nodes.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let replica_count = self.replica_count;
            let ack_count = self.ack_count;
            Range::create(
                _fbb,
                &RangeArgs {
                    stream_id,
                    epoch,
                    index,
                    start,
                    end,
                    nodes,
                    replica_count,
                    ack_count,
                },
            )
        }
    }
    pub enum CreateRangeRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CreateRangeRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CreateRangeRequest<'a> {
        type Inner = CreateRangeRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CreateRangeRequest<'a> {
        pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 4;
        pub const VT_RANGE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CreateRangeRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CreateRangeRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<CreateRangeRequest<'bldr>> {
            let mut builder = CreateRangeRequestBuilder::new(_fbb);
            if let Some(x) = args.range {
                builder.add_range(x);
            }
            builder.add_timeout_ms(args.timeout_ms);
            builder.finish()
        }

        pub fn unpack(&self) -> CreateRangeRequestT {
            let timeout_ms = self.timeout_ms();
            let range = {
                let x = self.range();
                Box::new(x.unpack())
            };
            CreateRangeRequestT { timeout_ms, range }
        }

        #[inline]
        pub fn timeout_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(CreateRangeRequest::VT_TIMEOUT_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn range(&self) -> Range<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Range>>(CreateRangeRequest::VT_RANGE, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for CreateRangeRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Range>>("range", Self::VT_RANGE, true)?
                .finish();
            Ok(())
        }
    }
    pub struct CreateRangeRequestArgs<'a> {
        pub timeout_ms: i32,
        pub range: Option<flatbuffers::WIPOffset<Range<'a>>>,
    }
    impl<'a> Default for CreateRangeRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            CreateRangeRequestArgs {
                timeout_ms: 0,
                range: None, // required field
            }
        }
    }

    pub struct CreateRangeRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CreateRangeRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_timeout_ms(&mut self, timeout_ms: i32) {
            self.fbb_
                .push_slot::<i32>(CreateRangeRequest::VT_TIMEOUT_MS, timeout_ms, 0);
        }
        #[inline]
        pub fn add_range(&mut self, range: flatbuffers::WIPOffset<Range<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Range>>(
                CreateRangeRequest::VT_RANGE,
                range,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CreateRangeRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CreateRangeRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CreateRangeRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, CreateRangeRequest::VT_RANGE, "range");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CreateRangeRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CreateRangeRequest");
            ds.field("timeout_ms", &self.timeout_ms());
            ds.field("range", &self.range());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct CreateRangeRequestT {
        pub timeout_ms: i32,
        pub range: Box<RangeT>,
    }
    impl Default for CreateRangeRequestT {
        fn default() -> Self {
            Self {
                timeout_ms: 0,
                range: Default::default(),
            }
        }
    }
    impl CreateRangeRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<CreateRangeRequest<'b>> {
            let timeout_ms = self.timeout_ms;
            let range = Some({
                let x = &self.range;
                x.pack(_fbb)
            });
            CreateRangeRequest::create(_fbb, &CreateRangeRequestArgs { timeout_ms, range })
        }
    }
    pub enum CreateRangeResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CreateRangeResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CreateRangeResponse<'a> {
        type Inner = CreateRangeResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CreateRangeResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_RANGE: flatbuffers::VOffsetT = 6;
        pub const VT_THROTTLE_TIME_MS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CreateRangeResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CreateRangeResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<CreateRangeResponse<'bldr>> {
            let mut builder = CreateRangeResponseBuilder::new(_fbb);
            builder.add_throttle_time_ms(args.throttle_time_ms);
            if let Some(x) = args.range {
                builder.add_range(x);
            }
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> CreateRangeResponseT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let range = self.range().map(|x| Box::new(x.unpack()));
            let throttle_time_ms = self.throttle_time_ms();
            CreateRangeResponseT {
                status,
                range,
                throttle_time_ms,
            }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(
                        CreateRangeResponse::VT_STATUS,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn range(&self) -> Option<Range<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Range>>(CreateRangeResponse::VT_RANGE, None)
            }
        }
        #[inline]
        pub fn throttle_time_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(CreateRangeResponse::VT_THROTTLE_TIME_MS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for CreateRangeResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Range>>("range", Self::VT_RANGE, false)?
                .visit_field::<i32>("throttle_time_ms", Self::VT_THROTTLE_TIME_MS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CreateRangeResponseArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub range: Option<flatbuffers::WIPOffset<Range<'a>>>,
        pub throttle_time_ms: i32,
    }
    impl<'a> Default for CreateRangeResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            CreateRangeResponseArgs {
                status: None, // required field
                range: None,
                throttle_time_ms: 0,
            }
        }
    }

    pub struct CreateRangeResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CreateRangeResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    CreateRangeResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_range(&mut self, range: flatbuffers::WIPOffset<Range<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Range>>(
                CreateRangeResponse::VT_RANGE,
                range,
            );
        }
        #[inline]
        pub fn add_throttle_time_ms(&mut self, throttle_time_ms: i32) {
            self.fbb_.push_slot::<i32>(
                CreateRangeResponse::VT_THROTTLE_TIME_MS,
                throttle_time_ms,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CreateRangeResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CreateRangeResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CreateRangeResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, CreateRangeResponse::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CreateRangeResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CreateRangeResponse");
            ds.field("status", &self.status());
            ds.field("range", &self.range());
            ds.field("throttle_time_ms", &self.throttle_time_ms());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct CreateRangeResponseT {
        pub status: Box<StatusT>,
        pub range: Option<Box<RangeT>>,
        pub throttle_time_ms: i32,
    }
    impl Default for CreateRangeResponseT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                range: None,
                throttle_time_ms: 0,
            }
        }
    }
    impl CreateRangeResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<CreateRangeResponse<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let range = self.range.as_ref().map(|x| x.pack(_fbb));
            let throttle_time_ms = self.throttle_time_ms;
            CreateRangeResponse::create(
                _fbb,
                &CreateRangeResponseArgs {
                    status,
                    range,
                    throttle_time_ms,
                },
            )
        }
    }
    pub enum SealRangeRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SealRangeRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SealRangeRequest<'a> {
        type Inner = SealRangeRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SealRangeRequest<'a> {
        pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 4;
        pub const VT_KIND: flatbuffers::VOffsetT = 6;
        pub const VT_RANGE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SealRangeRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SealRangeRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<SealRangeRequest<'bldr>> {
            let mut builder = SealRangeRequestBuilder::new(_fbb);
            if let Some(x) = args.range {
                builder.add_range(x);
            }
            builder.add_timeout_ms(args.timeout_ms);
            builder.add_kind(args.kind);
            builder.finish()
        }

        pub fn unpack(&self) -> SealRangeRequestT {
            let timeout_ms = self.timeout_ms();
            let kind = self.kind();
            let range = {
                let x = self.range();
                Box::new(x.unpack())
            };
            SealRangeRequestT {
                timeout_ms,
                kind,
                range,
            }
        }

        #[inline]
        pub fn timeout_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(SealRangeRequest::VT_TIMEOUT_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn kind(&self) -> SealKind {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<SealKind>(SealRangeRequest::VT_KIND, Some(SealKind::UNSPECIFIED))
                    .unwrap()
            }
        }
        #[inline]
        pub fn range(&self) -> Range<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Range>>(SealRangeRequest::VT_RANGE, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SealRangeRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                .visit_field::<SealKind>("kind", Self::VT_KIND, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Range>>("range", Self::VT_RANGE, true)?
                .finish();
            Ok(())
        }
    }
    pub struct SealRangeRequestArgs<'a> {
        pub timeout_ms: i32,
        pub kind: SealKind,
        pub range: Option<flatbuffers::WIPOffset<Range<'a>>>,
    }
    impl<'a> Default for SealRangeRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            SealRangeRequestArgs {
                timeout_ms: 0,
                kind: SealKind::UNSPECIFIED,
                range: None, // required field
            }
        }
    }

    pub struct SealRangeRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SealRangeRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_timeout_ms(&mut self, timeout_ms: i32) {
            self.fbb_
                .push_slot::<i32>(SealRangeRequest::VT_TIMEOUT_MS, timeout_ms, 0);
        }
        #[inline]
        pub fn add_kind(&mut self, kind: SealKind) {
            self.fbb_
                .push_slot::<SealKind>(SealRangeRequest::VT_KIND, kind, SealKind::UNSPECIFIED);
        }
        #[inline]
        pub fn add_range(&mut self, range: flatbuffers::WIPOffset<Range<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Range>>(
                SealRangeRequest::VT_RANGE,
                range,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SealRangeRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SealRangeRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SealRangeRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, SealRangeRequest::VT_RANGE, "range");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SealRangeRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SealRangeRequest");
            ds.field("timeout_ms", &self.timeout_ms());
            ds.field("kind", &self.kind());
            ds.field("range", &self.range());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SealRangeRequestT {
        pub timeout_ms: i32,
        pub kind: SealKind,
        pub range: Box<RangeT>,
    }
    impl Default for SealRangeRequestT {
        fn default() -> Self {
            Self {
                timeout_ms: 0,
                kind: SealKind::UNSPECIFIED,
                range: Default::default(),
            }
        }
    }
    impl SealRangeRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<SealRangeRequest<'b>> {
            let timeout_ms = self.timeout_ms;
            let kind = self.kind;
            let range = Some({
                let x = &self.range;
                x.pack(_fbb)
            });
            SealRangeRequest::create(
                _fbb,
                &SealRangeRequestArgs {
                    timeout_ms,
                    kind,
                    range,
                },
            )
        }
    }
    pub enum SealRangeResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SealRangeResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SealRangeResponse<'a> {
        type Inner = SealRangeResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SealRangeResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_RANGE: flatbuffers::VOffsetT = 6;
        pub const VT_THROTTLE_TIME_MS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SealRangeResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SealRangeResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<SealRangeResponse<'bldr>> {
            let mut builder = SealRangeResponseBuilder::new(_fbb);
            builder.add_throttle_time_ms(args.throttle_time_ms);
            if let Some(x) = args.range {
                builder.add_range(x);
            }
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> SealRangeResponseT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let range = self.range().map(|x| Box::new(x.unpack()));
            let throttle_time_ms = self.throttle_time_ms();
            SealRangeResponseT {
                status,
                range,
                throttle_time_ms,
            }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(SealRangeResponse::VT_STATUS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn range(&self) -> Option<Range<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Range>>(SealRangeResponse::VT_RANGE, None)
            }
        }
        #[inline]
        pub fn throttle_time_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(SealRangeResponse::VT_THROTTLE_TIME_MS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SealRangeResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Range>>("range", Self::VT_RANGE, false)?
                .visit_field::<i32>("throttle_time_ms", Self::VT_THROTTLE_TIME_MS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SealRangeResponseArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub range: Option<flatbuffers::WIPOffset<Range<'a>>>,
        pub throttle_time_ms: i32,
    }
    impl<'a> Default for SealRangeResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            SealRangeResponseArgs {
                status: None, // required field
                range: None,
                throttle_time_ms: 0,
            }
        }
    }

    pub struct SealRangeResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SealRangeResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    SealRangeResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_range(&mut self, range: flatbuffers::WIPOffset<Range<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Range>>(
                SealRangeResponse::VT_RANGE,
                range,
            );
        }
        #[inline]
        pub fn add_throttle_time_ms(&mut self, throttle_time_ms: i32) {
            self.fbb_
                .push_slot::<i32>(SealRangeResponse::VT_THROTTLE_TIME_MS, throttle_time_ms, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SealRangeResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SealRangeResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SealRangeResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, SealRangeResponse::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SealRangeResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SealRangeResponse");
            ds.field("status", &self.status());
            ds.field("range", &self.range());
            ds.field("throttle_time_ms", &self.throttle_time_ms());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SealRangeResponseT {
        pub status: Box<StatusT>,
        pub range: Option<Box<RangeT>>,
        pub throttle_time_ms: i32,
    }
    impl Default for SealRangeResponseT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                range: None,
                throttle_time_ms: 0,
            }
        }
    }
    impl SealRangeResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<SealRangeResponse<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let range = self.range.as_ref().map(|x| x.pack(_fbb));
            let throttle_time_ms = self.throttle_time_ms;
            SealRangeResponse::create(
                _fbb,
                &SealRangeResponseArgs {
                    status,
                    range,
                    throttle_time_ms,
                },
            )
        }
    }
    pub enum StreamOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Stream<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Stream<'a> {
        type Inner = Stream<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Stream<'a> {
        pub const VT_STREAM_ID: flatbuffers::VOffsetT = 4;
        pub const VT_REPLICA: flatbuffers::VOffsetT = 6;
        pub const VT_ACK_COUNT: flatbuffers::VOffsetT = 8;
        pub const VT_RETENTION_PERIOD_MS: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Stream { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StreamArgs,
        ) -> flatbuffers::WIPOffset<Stream<'bldr>> {
            let mut builder = StreamBuilder::new(_fbb);
            builder.add_retention_period_ms(args.retention_period_ms);
            builder.add_stream_id(args.stream_id);
            builder.add_ack_count(args.ack_count);
            builder.add_replica(args.replica);
            builder.finish()
        }

        pub fn unpack(&self) -> StreamT {
            let stream_id = self.stream_id();
            let replica = self.replica();
            let ack_count = self.ack_count();
            let retention_period_ms = self.retention_period_ms();
            StreamT {
                stream_id,
                replica,
                ack_count,
                retention_period_ms,
            }
        }

        #[inline]
        pub fn stream_id(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(Stream::VT_STREAM_ID, Some(-1))
                    .unwrap()
            }
        }
        #[inline]
        pub fn replica(&self) -> i8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i8>(Stream::VT_REPLICA, Some(0)).unwrap() }
        }
        #[inline]
        pub fn ack_count(&self) -> i8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i8>(Stream::VT_ACK_COUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn retention_period_ms(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(Stream::VT_RETENTION_PERIOD_MS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Stream<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i64>("stream_id", Self::VT_STREAM_ID, false)?
                .visit_field::<i8>("replica", Self::VT_REPLICA, false)?
                .visit_field::<i8>("ack_count", Self::VT_ACK_COUNT, false)?
                .visit_field::<i64>("retention_period_ms", Self::VT_RETENTION_PERIOD_MS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StreamArgs {
        pub stream_id: i64,
        pub replica: i8,
        pub ack_count: i8,
        pub retention_period_ms: i64,
    }
    impl<'a> Default for StreamArgs {
        #[inline]
        fn default() -> Self {
            StreamArgs {
                stream_id: -1,
                replica: 0,
                ack_count: 0,
                retention_period_ms: 0,
            }
        }
    }

    pub struct StreamBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StreamBuilder<'a, 'b> {
        #[inline]
        pub fn add_stream_id(&mut self, stream_id: i64) {
            self.fbb_
                .push_slot::<i64>(Stream::VT_STREAM_ID, stream_id, -1);
        }
        #[inline]
        pub fn add_replica(&mut self, replica: i8) {
            self.fbb_.push_slot::<i8>(Stream::VT_REPLICA, replica, 0);
        }
        #[inline]
        pub fn add_ack_count(&mut self, ack_count: i8) {
            self.fbb_
                .push_slot::<i8>(Stream::VT_ACK_COUNT, ack_count, 0);
        }
        #[inline]
        pub fn add_retention_period_ms(&mut self, retention_period_ms: i64) {
            self.fbb_
                .push_slot::<i64>(Stream::VT_RETENTION_PERIOD_MS, retention_period_ms, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StreamBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StreamBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Stream<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Stream<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Stream");
            ds.field("stream_id", &self.stream_id());
            ds.field("replica", &self.replica());
            ds.field("ack_count", &self.ack_count());
            ds.field("retention_period_ms", &self.retention_period_ms());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct StreamT {
        pub stream_id: i64,
        pub replica: i8,
        pub ack_count: i8,
        pub retention_period_ms: i64,
    }
    impl Default for StreamT {
        fn default() -> Self {
            Self {
                stream_id: -1,
                replica: 0,
                ack_count: 0,
                retention_period_ms: 0,
            }
        }
    }
    impl StreamT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Stream<'b>> {
            let stream_id = self.stream_id;
            let replica = self.replica;
            let ack_count = self.ack_count;
            let retention_period_ms = self.retention_period_ms;
            Stream::create(
                _fbb,
                &StreamArgs {
                    stream_id,
                    replica,
                    ack_count,
                    retention_period_ms,
                },
            )
        }
    }
    pub enum CreateStreamRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CreateStreamRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CreateStreamRequest<'a> {
        type Inner = CreateStreamRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CreateStreamRequest<'a> {
        pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 4;
        pub const VT_STREAM: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CreateStreamRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CreateStreamRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<CreateStreamRequest<'bldr>> {
            let mut builder = CreateStreamRequestBuilder::new(_fbb);
            if let Some(x) = args.stream {
                builder.add_stream(x);
            }
            builder.add_timeout_ms(args.timeout_ms);
            builder.finish()
        }

        pub fn unpack(&self) -> CreateStreamRequestT {
            let timeout_ms = self.timeout_ms();
            let stream = {
                let x = self.stream();
                Box::new(x.unpack())
            };
            CreateStreamRequestT { timeout_ms, stream }
        }

        #[inline]
        pub fn timeout_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(CreateStreamRequest::VT_TIMEOUT_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stream(&self) -> Stream<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Stream>>(
                        CreateStreamRequest::VT_STREAM,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for CreateStreamRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Stream>>(
                    "stream",
                    Self::VT_STREAM,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct CreateStreamRequestArgs<'a> {
        pub timeout_ms: i32,
        pub stream: Option<flatbuffers::WIPOffset<Stream<'a>>>,
    }
    impl<'a> Default for CreateStreamRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            CreateStreamRequestArgs {
                timeout_ms: 0,
                stream: None, // required field
            }
        }
    }

    pub struct CreateStreamRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CreateStreamRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_timeout_ms(&mut self, timeout_ms: i32) {
            self.fbb_
                .push_slot::<i32>(CreateStreamRequest::VT_TIMEOUT_MS, timeout_ms, 0);
        }
        #[inline]
        pub fn add_stream(&mut self, stream: flatbuffers::WIPOffset<Stream<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Stream>>(
                    CreateStreamRequest::VT_STREAM,
                    stream,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CreateStreamRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CreateStreamRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CreateStreamRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, CreateStreamRequest::VT_STREAM, "stream");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CreateStreamRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CreateStreamRequest");
            ds.field("timeout_ms", &self.timeout_ms());
            ds.field("stream", &self.stream());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct CreateStreamRequestT {
        pub timeout_ms: i32,
        pub stream: Box<StreamT>,
    }
    impl Default for CreateStreamRequestT {
        fn default() -> Self {
            Self {
                timeout_ms: 0,
                stream: Default::default(),
            }
        }
    }
    impl CreateStreamRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<CreateStreamRequest<'b>> {
            let timeout_ms = self.timeout_ms;
            let stream = Some({
                let x = &self.stream;
                x.pack(_fbb)
            });
            CreateStreamRequest::create(_fbb, &CreateStreamRequestArgs { timeout_ms, stream })
        }
    }
    pub enum CreateStreamResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CreateStreamResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CreateStreamResponse<'a> {
        type Inner = CreateStreamResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CreateStreamResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_STREAM: flatbuffers::VOffsetT = 6;
        pub const VT_THROTTLE_TIME_MS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CreateStreamResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CreateStreamResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<CreateStreamResponse<'bldr>> {
            let mut builder = CreateStreamResponseBuilder::new(_fbb);
            builder.add_throttle_time_ms(args.throttle_time_ms);
            if let Some(x) = args.stream {
                builder.add_stream(x);
            }
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> CreateStreamResponseT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let stream = self.stream().map(|x| Box::new(x.unpack()));
            let throttle_time_ms = self.throttle_time_ms();
            CreateStreamResponseT {
                status,
                stream,
                throttle_time_ms,
            }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(
                        CreateStreamResponse::VT_STATUS,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn stream(&self) -> Option<Stream<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<Stream>>(
                    CreateStreamResponse::VT_STREAM,
                    None,
                )
            }
        }
        #[inline]
        pub fn throttle_time_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(CreateStreamResponse::VT_THROTTLE_TIME_MS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for CreateStreamResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Stream>>(
                    "stream",
                    Self::VT_STREAM,
                    false,
                )?
                .visit_field::<i32>("throttle_time_ms", Self::VT_THROTTLE_TIME_MS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CreateStreamResponseArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub stream: Option<flatbuffers::WIPOffset<Stream<'a>>>,
        pub throttle_time_ms: i32,
    }
    impl<'a> Default for CreateStreamResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            CreateStreamResponseArgs {
                status: None, // required field
                stream: None,
                throttle_time_ms: 0,
            }
        }
    }

    pub struct CreateStreamResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CreateStreamResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    CreateStreamResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_stream(&mut self, stream: flatbuffers::WIPOffset<Stream<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Stream>>(
                    CreateStreamResponse::VT_STREAM,
                    stream,
                );
        }
        #[inline]
        pub fn add_throttle_time_ms(&mut self, throttle_time_ms: i32) {
            self.fbb_.push_slot::<i32>(
                CreateStreamResponse::VT_THROTTLE_TIME_MS,
                throttle_time_ms,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CreateStreamResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CreateStreamResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CreateStreamResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, CreateStreamResponse::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CreateStreamResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CreateStreamResponse");
            ds.field("status", &self.status());
            ds.field("stream", &self.stream());
            ds.field("throttle_time_ms", &self.throttle_time_ms());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct CreateStreamResponseT {
        pub status: Box<StatusT>,
        pub stream: Option<Box<StreamT>>,
        pub throttle_time_ms: i32,
    }
    impl Default for CreateStreamResponseT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                stream: None,
                throttle_time_ms: 0,
            }
        }
    }
    impl CreateStreamResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<CreateStreamResponse<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let stream = self.stream.as_ref().map(|x| x.pack(_fbb));
            let throttle_time_ms = self.throttle_time_ms;
            CreateStreamResponse::create(
                _fbb,
                &CreateStreamResponseArgs {
                    status,
                    stream,
                    throttle_time_ms,
                },
            )
        }
    }
    pub enum DeleteStreamRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DeleteStreamRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DeleteStreamRequest<'a> {
        type Inner = DeleteStreamRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DeleteStreamRequest<'a> {
        pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 4;
        pub const VT_STREAM_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DeleteStreamRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DeleteStreamRequestArgs,
        ) -> flatbuffers::WIPOffset<DeleteStreamRequest<'bldr>> {
            let mut builder = DeleteStreamRequestBuilder::new(_fbb);
            builder.add_stream_id(args.stream_id);
            builder.add_timeout_ms(args.timeout_ms);
            builder.finish()
        }

        pub fn unpack(&self) -> DeleteStreamRequestT {
            let timeout_ms = self.timeout_ms();
            let stream_id = self.stream_id();
            DeleteStreamRequestT {
                timeout_ms,
                stream_id,
            }
        }

        #[inline]
        pub fn timeout_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DeleteStreamRequest::VT_TIMEOUT_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stream_id(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(DeleteStreamRequest::VT_STREAM_ID, Some(-1))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DeleteStreamRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                .visit_field::<i64>("stream_id", Self::VT_STREAM_ID, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DeleteStreamRequestArgs {
        pub timeout_ms: i32,
        pub stream_id: i64,
    }
    impl<'a> Default for DeleteStreamRequestArgs {
        #[inline]
        fn default() -> Self {
            DeleteStreamRequestArgs {
                timeout_ms: 0,
                stream_id: -1,
            }
        }
    }

    pub struct DeleteStreamRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DeleteStreamRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_timeout_ms(&mut self, timeout_ms: i32) {
            self.fbb_
                .push_slot::<i32>(DeleteStreamRequest::VT_TIMEOUT_MS, timeout_ms, 0);
        }
        #[inline]
        pub fn add_stream_id(&mut self, stream_id: i64) {
            self.fbb_
                .push_slot::<i64>(DeleteStreamRequest::VT_STREAM_ID, stream_id, -1);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DeleteStreamRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DeleteStreamRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DeleteStreamRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DeleteStreamRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DeleteStreamRequest");
            ds.field("timeout_ms", &self.timeout_ms());
            ds.field("stream_id", &self.stream_id());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct DeleteStreamRequestT {
        pub timeout_ms: i32,
        pub stream_id: i64,
    }
    impl Default for DeleteStreamRequestT {
        fn default() -> Self {
            Self {
                timeout_ms: 0,
                stream_id: -1,
            }
        }
    }
    impl DeleteStreamRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<DeleteStreamRequest<'b>> {
            let timeout_ms = self.timeout_ms;
            let stream_id = self.stream_id;
            DeleteStreamRequest::create(
                _fbb,
                &DeleteStreamRequestArgs {
                    timeout_ms,
                    stream_id,
                },
            )
        }
    }
    pub enum DeleteStreamResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DeleteStreamResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DeleteStreamResponse<'a> {
        type Inner = DeleteStreamResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DeleteStreamResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_STREAM: flatbuffers::VOffsetT = 6;
        pub const VT_THROTTLE_TIME_MS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DeleteStreamResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DeleteStreamResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<DeleteStreamResponse<'bldr>> {
            let mut builder = DeleteStreamResponseBuilder::new(_fbb);
            builder.add_throttle_time_ms(args.throttle_time_ms);
            if let Some(x) = args.stream {
                builder.add_stream(x);
            }
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> DeleteStreamResponseT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let stream = self.stream().map(|x| Box::new(x.unpack()));
            let throttle_time_ms = self.throttle_time_ms();
            DeleteStreamResponseT {
                status,
                stream,
                throttle_time_ms,
            }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(
                        DeleteStreamResponse::VT_STATUS,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn stream(&self) -> Option<Stream<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<Stream>>(
                    DeleteStreamResponse::VT_STREAM,
                    None,
                )
            }
        }
        #[inline]
        pub fn throttle_time_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DeleteStreamResponse::VT_THROTTLE_TIME_MS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DeleteStreamResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Stream>>(
                    "stream",
                    Self::VT_STREAM,
                    false,
                )?
                .visit_field::<i32>("throttle_time_ms", Self::VT_THROTTLE_TIME_MS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DeleteStreamResponseArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub stream: Option<flatbuffers::WIPOffset<Stream<'a>>>,
        pub throttle_time_ms: i32,
    }
    impl<'a> Default for DeleteStreamResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            DeleteStreamResponseArgs {
                status: None, // required field
                stream: None,
                throttle_time_ms: 0,
            }
        }
    }

    pub struct DeleteStreamResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DeleteStreamResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    DeleteStreamResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_stream(&mut self, stream: flatbuffers::WIPOffset<Stream<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Stream>>(
                    DeleteStreamResponse::VT_STREAM,
                    stream,
                );
        }
        #[inline]
        pub fn add_throttle_time_ms(&mut self, throttle_time_ms: i32) {
            self.fbb_.push_slot::<i32>(
                DeleteStreamResponse::VT_THROTTLE_TIME_MS,
                throttle_time_ms,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DeleteStreamResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DeleteStreamResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DeleteStreamResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, DeleteStreamResponse::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DeleteStreamResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DeleteStreamResponse");
            ds.field("status", &self.status());
            ds.field("stream", &self.stream());
            ds.field("throttle_time_ms", &self.throttle_time_ms());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct DeleteStreamResponseT {
        pub status: Box<StatusT>,
        pub stream: Option<Box<StreamT>>,
        pub throttle_time_ms: i32,
    }
    impl Default for DeleteStreamResponseT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                stream: None,
                throttle_time_ms: 0,
            }
        }
    }
    impl DeleteStreamResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<DeleteStreamResponse<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let stream = self.stream.as_ref().map(|x| x.pack(_fbb));
            let throttle_time_ms = self.throttle_time_ms;
            DeleteStreamResponse::create(
                _fbb,
                &DeleteStreamResponseArgs {
                    status,
                    stream,
                    throttle_time_ms,
                },
            )
        }
    }
    pub enum UpdateStreamRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdateStreamRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdateStreamRequest<'a> {
        type Inner = UpdateStreamRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UpdateStreamRequest<'a> {
        pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 4;
        pub const VT_STREAM: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdateStreamRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UpdateStreamRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdateStreamRequest<'bldr>> {
            let mut builder = UpdateStreamRequestBuilder::new(_fbb);
            if let Some(x) = args.stream {
                builder.add_stream(x);
            }
            builder.add_timeout_ms(args.timeout_ms);
            builder.finish()
        }

        pub fn unpack(&self) -> UpdateStreamRequestT {
            let timeout_ms = self.timeout_ms();
            let stream = self.stream().map(|x| Box::new(x.unpack()));
            UpdateStreamRequestT { timeout_ms, stream }
        }

        #[inline]
        pub fn timeout_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(UpdateStreamRequest::VT_TIMEOUT_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stream(&self) -> Option<Stream<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<Stream>>(
                    UpdateStreamRequest::VT_STREAM,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for UpdateStreamRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Stream>>(
                    "stream",
                    Self::VT_STREAM,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UpdateStreamRequestArgs<'a> {
        pub timeout_ms: i32,
        pub stream: Option<flatbuffers::WIPOffset<Stream<'a>>>,
    }
    impl<'a> Default for UpdateStreamRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdateStreamRequestArgs {
                timeout_ms: 0,
                stream: None,
            }
        }
    }

    pub struct UpdateStreamRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UpdateStreamRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_timeout_ms(&mut self, timeout_ms: i32) {
            self.fbb_
                .push_slot::<i32>(UpdateStreamRequest::VT_TIMEOUT_MS, timeout_ms, 0);
        }
        #[inline]
        pub fn add_stream(&mut self, stream: flatbuffers::WIPOffset<Stream<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Stream>>(
                    UpdateStreamRequest::VT_STREAM,
                    stream,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UpdateStreamRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UpdateStreamRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdateStreamRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdateStreamRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdateStreamRequest");
            ds.field("timeout_ms", &self.timeout_ms());
            ds.field("stream", &self.stream());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateStreamRequestT {
        pub timeout_ms: i32,
        pub stream: Option<Box<StreamT>>,
    }
    impl Default for UpdateStreamRequestT {
        fn default() -> Self {
            Self {
                timeout_ms: 0,
                stream: None,
            }
        }
    }
    impl UpdateStreamRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<UpdateStreamRequest<'b>> {
            let timeout_ms = self.timeout_ms;
            let stream = self.stream.as_ref().map(|x| x.pack(_fbb));
            UpdateStreamRequest::create(_fbb, &UpdateStreamRequestArgs { timeout_ms, stream })
        }
    }
    pub enum UpdateStreamResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdateStreamResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdateStreamResponse<'a> {
        type Inner = UpdateStreamResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UpdateStreamResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_THROTTLE_TIME_MS: flatbuffers::VOffsetT = 6;
        pub const VT_STREAM: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdateStreamResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UpdateStreamResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdateStreamResponse<'bldr>> {
            let mut builder = UpdateStreamResponseBuilder::new(_fbb);
            if let Some(x) = args.stream {
                builder.add_stream(x);
            }
            builder.add_throttle_time_ms(args.throttle_time_ms);
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> UpdateStreamResponseT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let throttle_time_ms = self.throttle_time_ms();
            let stream = self.stream().map(|x| Box::new(x.unpack()));
            UpdateStreamResponseT {
                status,
                throttle_time_ms,
                stream,
            }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(
                        UpdateStreamResponse::VT_STATUS,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn throttle_time_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(UpdateStreamResponse::VT_THROTTLE_TIME_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stream(&self) -> Option<Stream<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<Stream>>(
                    UpdateStreamResponse::VT_STREAM,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for UpdateStreamResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<i32>("throttle_time_ms", Self::VT_THROTTLE_TIME_MS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Stream>>(
                    "stream",
                    Self::VT_STREAM,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UpdateStreamResponseArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub throttle_time_ms: i32,
        pub stream: Option<flatbuffers::WIPOffset<Stream<'a>>>,
    }
    impl<'a> Default for UpdateStreamResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdateStreamResponseArgs {
                status: None, // required field
                throttle_time_ms: 0,
                stream: None,
            }
        }
    }

    pub struct UpdateStreamResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UpdateStreamResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    UpdateStreamResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_throttle_time_ms(&mut self, throttle_time_ms: i32) {
            self.fbb_.push_slot::<i32>(
                UpdateStreamResponse::VT_THROTTLE_TIME_MS,
                throttle_time_ms,
                0,
            );
        }
        #[inline]
        pub fn add_stream(&mut self, stream: flatbuffers::WIPOffset<Stream<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Stream>>(
                    UpdateStreamResponse::VT_STREAM,
                    stream,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UpdateStreamResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UpdateStreamResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdateStreamResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, UpdateStreamResponse::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdateStreamResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdateStreamResponse");
            ds.field("status", &self.status());
            ds.field("throttle_time_ms", &self.throttle_time_ms());
            ds.field("stream", &self.stream());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct UpdateStreamResponseT {
        pub status: Box<StatusT>,
        pub throttle_time_ms: i32,
        pub stream: Option<Box<StreamT>>,
    }
    impl Default for UpdateStreamResponseT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                throttle_time_ms: 0,
                stream: None,
            }
        }
    }
    impl UpdateStreamResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<UpdateStreamResponse<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let throttle_time_ms = self.throttle_time_ms;
            let stream = self.stream.as_ref().map(|x| x.pack(_fbb));
            UpdateStreamResponse::create(
                _fbb,
                &UpdateStreamResponseArgs {
                    status,
                    throttle_time_ms,
                    stream,
                },
            )
        }
    }
    pub enum DescribeStreamRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DescribeStreamRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DescribeStreamRequest<'a> {
        type Inner = DescribeStreamRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DescribeStreamRequest<'a> {
        pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 4;
        pub const VT_STREAM_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DescribeStreamRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DescribeStreamRequestArgs,
        ) -> flatbuffers::WIPOffset<DescribeStreamRequest<'bldr>> {
            let mut builder = DescribeStreamRequestBuilder::new(_fbb);
            builder.add_stream_id(args.stream_id);
            builder.add_timeout_ms(args.timeout_ms);
            builder.finish()
        }

        pub fn unpack(&self) -> DescribeStreamRequestT {
            let timeout_ms = self.timeout_ms();
            let stream_id = self.stream_id();
            DescribeStreamRequestT {
                timeout_ms,
                stream_id,
            }
        }

        #[inline]
        pub fn timeout_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DescribeStreamRequest::VT_TIMEOUT_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stream_id(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(DescribeStreamRequest::VT_STREAM_ID, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DescribeStreamRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                .visit_field::<i64>("stream_id", Self::VT_STREAM_ID, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DescribeStreamRequestArgs {
        pub timeout_ms: i32,
        pub stream_id: i64,
    }
    impl<'a> Default for DescribeStreamRequestArgs {
        #[inline]
        fn default() -> Self {
            DescribeStreamRequestArgs {
                timeout_ms: 0,
                stream_id: 0,
            }
        }
    }

    pub struct DescribeStreamRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DescribeStreamRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_timeout_ms(&mut self, timeout_ms: i32) {
            self.fbb_
                .push_slot::<i32>(DescribeStreamRequest::VT_TIMEOUT_MS, timeout_ms, 0);
        }
        #[inline]
        pub fn add_stream_id(&mut self, stream_id: i64) {
            self.fbb_
                .push_slot::<i64>(DescribeStreamRequest::VT_STREAM_ID, stream_id, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DescribeStreamRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DescribeStreamRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DescribeStreamRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DescribeStreamRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DescribeStreamRequest");
            ds.field("timeout_ms", &self.timeout_ms());
            ds.field("stream_id", &self.stream_id());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct DescribeStreamRequestT {
        pub timeout_ms: i32,
        pub stream_id: i64,
    }
    impl Default for DescribeStreamRequestT {
        fn default() -> Self {
            Self {
                timeout_ms: 0,
                stream_id: 0,
            }
        }
    }
    impl DescribeStreamRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<DescribeStreamRequest<'b>> {
            let timeout_ms = self.timeout_ms;
            let stream_id = self.stream_id;
            DescribeStreamRequest::create(
                _fbb,
                &DescribeStreamRequestArgs {
                    timeout_ms,
                    stream_id,
                },
            )
        }
    }
    pub enum DescribeStreamResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DescribeStreamResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DescribeStreamResponse<'a> {
        type Inner = DescribeStreamResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DescribeStreamResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_THROTTLE_TIME_MS: flatbuffers::VOffsetT = 6;
        pub const VT_STREAM: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DescribeStreamResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DescribeStreamResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<DescribeStreamResponse<'bldr>> {
            let mut builder = DescribeStreamResponseBuilder::new(_fbb);
            if let Some(x) = args.stream {
                builder.add_stream(x);
            }
            builder.add_throttle_time_ms(args.throttle_time_ms);
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> DescribeStreamResponseT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let throttle_time_ms = self.throttle_time_ms();
            let stream = self.stream().map(|x| Box::new(x.unpack()));
            DescribeStreamResponseT {
                status,
                throttle_time_ms,
                stream,
            }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(
                        DescribeStreamResponse::VT_STATUS,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn throttle_time_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DescribeStreamResponse::VT_THROTTLE_TIME_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stream(&self) -> Option<Stream<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<Stream>>(
                    DescribeStreamResponse::VT_STREAM,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for DescribeStreamResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<i32>("throttle_time_ms", Self::VT_THROTTLE_TIME_MS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Stream>>(
                    "stream",
                    Self::VT_STREAM,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct DescribeStreamResponseArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub throttle_time_ms: i32,
        pub stream: Option<flatbuffers::WIPOffset<Stream<'a>>>,
    }
    impl<'a> Default for DescribeStreamResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            DescribeStreamResponseArgs {
                status: None, // required field
                throttle_time_ms: 0,
                stream: None,
            }
        }
    }

    pub struct DescribeStreamResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DescribeStreamResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    DescribeStreamResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_throttle_time_ms(&mut self, throttle_time_ms: i32) {
            self.fbb_.push_slot::<i32>(
                DescribeStreamResponse::VT_THROTTLE_TIME_MS,
                throttle_time_ms,
                0,
            );
        }
        #[inline]
        pub fn add_stream(&mut self, stream: flatbuffers::WIPOffset<Stream<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Stream>>(
                    DescribeStreamResponse::VT_STREAM,
                    stream,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DescribeStreamResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DescribeStreamResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DescribeStreamResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, DescribeStreamResponse::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DescribeStreamResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DescribeStreamResponse");
            ds.field("status", &self.status());
            ds.field("throttle_time_ms", &self.throttle_time_ms());
            ds.field("stream", &self.stream());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct DescribeStreamResponseT {
        pub status: Box<StatusT>,
        pub throttle_time_ms: i32,
        pub stream: Option<Box<StreamT>>,
    }
    impl Default for DescribeStreamResponseT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                throttle_time_ms: 0,
                stream: None,
            }
        }
    }
    impl DescribeStreamResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<DescribeStreamResponse<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let throttle_time_ms = self.throttle_time_ms;
            let stream = self.stream.as_ref().map(|x| x.pack(_fbb));
            DescribeStreamResponse::create(
                _fbb,
                &DescribeStreamResponseArgs {
                    status,
                    throttle_time_ms,
                    stream,
                },
            )
        }
    }
    pub enum TrimStreamRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TrimStreamRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TrimStreamRequest<'a> {
        type Inner = TrimStreamRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TrimStreamRequest<'a> {
        pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 4;
        pub const VT_STREAM_ID: flatbuffers::VOffsetT = 6;
        pub const VT_MIN_OFFSET: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TrimStreamRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TrimStreamRequestArgs,
        ) -> flatbuffers::WIPOffset<TrimStreamRequest<'bldr>> {
            let mut builder = TrimStreamRequestBuilder::new(_fbb);
            builder.add_min_offset(args.min_offset);
            builder.add_stream_id(args.stream_id);
            builder.add_timeout_ms(args.timeout_ms);
            builder.finish()
        }

        pub fn unpack(&self) -> TrimStreamRequestT {
            let timeout_ms = self.timeout_ms();
            let stream_id = self.stream_id();
            let min_offset = self.min_offset();
            TrimStreamRequestT {
                timeout_ms,
                stream_id,
                min_offset,
            }
        }

        #[inline]
        pub fn timeout_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(TrimStreamRequest::VT_TIMEOUT_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stream_id(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(TrimStreamRequest::VT_STREAM_ID, Some(-1))
                    .unwrap()
            }
        }
        #[inline]
        pub fn min_offset(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(TrimStreamRequest::VT_MIN_OFFSET, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TrimStreamRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                .visit_field::<i64>("stream_id", Self::VT_STREAM_ID, false)?
                .visit_field::<i64>("min_offset", Self::VT_MIN_OFFSET, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TrimStreamRequestArgs {
        pub timeout_ms: i32,
        pub stream_id: i64,
        pub min_offset: i64,
    }
    impl<'a> Default for TrimStreamRequestArgs {
        #[inline]
        fn default() -> Self {
            TrimStreamRequestArgs {
                timeout_ms: 0,
                stream_id: -1,
                min_offset: 0,
            }
        }
    }

    pub struct TrimStreamRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TrimStreamRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_timeout_ms(&mut self, timeout_ms: i32) {
            self.fbb_
                .push_slot::<i32>(TrimStreamRequest::VT_TIMEOUT_MS, timeout_ms, 0);
        }
        #[inline]
        pub fn add_stream_id(&mut self, stream_id: i64) {
            self.fbb_
                .push_slot::<i64>(TrimStreamRequest::VT_STREAM_ID, stream_id, -1);
        }
        #[inline]
        pub fn add_min_offset(&mut self, min_offset: i64) {
            self.fbb_
                .push_slot::<i64>(TrimStreamRequest::VT_MIN_OFFSET, min_offset, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TrimStreamRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TrimStreamRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TrimStreamRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TrimStreamRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TrimStreamRequest");
            ds.field("timeout_ms", &self.timeout_ms());
            ds.field("stream_id", &self.stream_id());
            ds.field("min_offset", &self.min_offset());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TrimStreamRequestT {
        pub timeout_ms: i32,
        pub stream_id: i64,
        pub min_offset: i64,
    }
    impl Default for TrimStreamRequestT {
        fn default() -> Self {
            Self {
                timeout_ms: 0,
                stream_id: -1,
                min_offset: 0,
            }
        }
    }
    impl TrimStreamRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<TrimStreamRequest<'b>> {
            let timeout_ms = self.timeout_ms;
            let stream_id = self.stream_id;
            let min_offset = self.min_offset;
            TrimStreamRequest::create(
                _fbb,
                &TrimStreamRequestArgs {
                    timeout_ms,
                    stream_id,
                    min_offset,
                },
            )
        }
    }
    pub enum TrimStreamsResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TrimStreamsResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TrimStreamsResponse<'a> {
        type Inner = TrimStreamsResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TrimStreamsResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_THROTTLE_TIME_MS: flatbuffers::VOffsetT = 6;
        pub const VT_STREAM: flatbuffers::VOffsetT = 8;
        pub const VT_RANGE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TrimStreamsResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TrimStreamsResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<TrimStreamsResponse<'bldr>> {
            let mut builder = TrimStreamsResponseBuilder::new(_fbb);
            if let Some(x) = args.range {
                builder.add_range(x);
            }
            if let Some(x) = args.stream {
                builder.add_stream(x);
            }
            builder.add_throttle_time_ms(args.throttle_time_ms);
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> TrimStreamsResponseT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let throttle_time_ms = self.throttle_time_ms();
            let stream = self.stream().map(|x| Box::new(x.unpack()));
            let range = self.range().map(|x| Box::new(x.unpack()));
            TrimStreamsResponseT {
                status,
                throttle_time_ms,
                stream,
                range,
            }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(
                        TrimStreamsResponse::VT_STATUS,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn throttle_time_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(TrimStreamsResponse::VT_THROTTLE_TIME_MS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stream(&self) -> Option<Stream<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<Stream>>(
                    TrimStreamsResponse::VT_STREAM,
                    None,
                )
            }
        }
        #[inline]
        pub fn range(&self) -> Option<Range<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Range>>(TrimStreamsResponse::VT_RANGE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TrimStreamsResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<i32>("throttle_time_ms", Self::VT_THROTTLE_TIME_MS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Stream>>(
                    "stream",
                    Self::VT_STREAM,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Range>>("range", Self::VT_RANGE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TrimStreamsResponseArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub throttle_time_ms: i32,
        pub stream: Option<flatbuffers::WIPOffset<Stream<'a>>>,
        pub range: Option<flatbuffers::WIPOffset<Range<'a>>>,
    }
    impl<'a> Default for TrimStreamsResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            TrimStreamsResponseArgs {
                status: None, // required field
                throttle_time_ms: 0,
                stream: None,
                range: None,
            }
        }
    }

    pub struct TrimStreamsResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TrimStreamsResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    TrimStreamsResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_throttle_time_ms(&mut self, throttle_time_ms: i32) {
            self.fbb_.push_slot::<i32>(
                TrimStreamsResponse::VT_THROTTLE_TIME_MS,
                throttle_time_ms,
                0,
            );
        }
        #[inline]
        pub fn add_stream(&mut self, stream: flatbuffers::WIPOffset<Stream<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Stream>>(
                    TrimStreamsResponse::VT_STREAM,
                    stream,
                );
        }
        #[inline]
        pub fn add_range(&mut self, range: flatbuffers::WIPOffset<Range<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Range>>(
                TrimStreamsResponse::VT_RANGE,
                range,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TrimStreamsResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TrimStreamsResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TrimStreamsResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, TrimStreamsResponse::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TrimStreamsResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TrimStreamsResponse");
            ds.field("status", &self.status());
            ds.field("throttle_time_ms", &self.throttle_time_ms());
            ds.field("stream", &self.stream());
            ds.field("range", &self.range());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TrimStreamsResponseT {
        pub status: Box<StatusT>,
        pub throttle_time_ms: i32,
        pub stream: Option<Box<StreamT>>,
        pub range: Option<Box<RangeT>>,
    }
    impl Default for TrimStreamsResponseT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                throttle_time_ms: 0,
                stream: None,
                range: None,
            }
        }
    }
    impl TrimStreamsResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<TrimStreamsResponse<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let throttle_time_ms = self.throttle_time_ms;
            let stream = self.stream.as_ref().map(|x| x.pack(_fbb));
            let range = self.range.as_ref().map(|x| x.pack(_fbb));
            TrimStreamsResponse::create(
                _fbb,
                &TrimStreamsResponseArgs {
                    status,
                    throttle_time_ms,
                    stream,
                    range,
                },
            )
        }
    }
    pub enum ReportMetricsRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ReportMetricsRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReportMetricsRequest<'a> {
        type Inner = ReportMetricsRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ReportMetricsRequest<'a> {
        pub const VT_DATA_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_METRICS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReportMetricsRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReportMetricsRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<ReportMetricsRequest<'bldr>> {
            let mut builder = ReportMetricsRequestBuilder::new(_fbb);
            if let Some(x) = args.metrics {
                builder.add_metrics(x);
            }
            if let Some(x) = args.data_node {
                builder.add_data_node(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ReportMetricsRequestT {
            let data_node = self.data_node().map(|x| Box::new(x.unpack()));
            let metrics = self.metrics().map(|x| Box::new(x.unpack()));
            ReportMetricsRequestT { data_node, metrics }
        }

        #[inline]
        pub fn data_node(&self) -> Option<DataNode<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<DataNode>>(
                    ReportMetricsRequest::VT_DATA_NODE,
                    None,
                )
            }
        }
        #[inline]
        pub fn metrics(&self) -> Option<DataNodeMetrics<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<DataNodeMetrics>>(
                        ReportMetricsRequest::VT_METRICS,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for ReportMetricsRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<DataNode>>(
                    "data_node",
                    Self::VT_DATA_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<DataNodeMetrics>>(
                    "metrics",
                    Self::VT_METRICS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ReportMetricsRequestArgs<'a> {
        pub data_node: Option<flatbuffers::WIPOffset<DataNode<'a>>>,
        pub metrics: Option<flatbuffers::WIPOffset<DataNodeMetrics<'a>>>,
    }
    impl<'a> Default for ReportMetricsRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            ReportMetricsRequestArgs {
                data_node: None,
                metrics: None,
            }
        }
    }

    pub struct ReportMetricsRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReportMetricsRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_data_node(&mut self, data_node: flatbuffers::WIPOffset<DataNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<DataNode>>(
                    ReportMetricsRequest::VT_DATA_NODE,
                    data_node,
                );
        }
        #[inline]
        pub fn add_metrics(&mut self, metrics: flatbuffers::WIPOffset<DataNodeMetrics<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<DataNodeMetrics>>(
                    ReportMetricsRequest::VT_METRICS,
                    metrics,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReportMetricsRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReportMetricsRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReportMetricsRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ReportMetricsRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ReportMetricsRequest");
            ds.field("data_node", &self.data_node());
            ds.field("metrics", &self.metrics());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ReportMetricsRequestT {
        pub data_node: Option<Box<DataNodeT>>,
        pub metrics: Option<Box<DataNodeMetricsT>>,
    }
    impl Default for ReportMetricsRequestT {
        fn default() -> Self {
            Self {
                data_node: None,
                metrics: None,
            }
        }
    }
    impl ReportMetricsRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<ReportMetricsRequest<'b>> {
            let data_node = self.data_node.as_ref().map(|x| x.pack(_fbb));
            let metrics = self.metrics.as_ref().map(|x| x.pack(_fbb));
            ReportMetricsRequest::create(_fbb, &ReportMetricsRequestArgs { data_node, metrics })
        }
    }
    pub enum DataNodeMetricsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DataNodeMetrics<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DataNodeMetrics<'a> {
        type Inner = DataNodeMetrics<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DataNodeMetrics<'a> {
        pub const VT_DISK_IN_RATE: flatbuffers::VOffsetT = 4;
        pub const VT_DISK_OUT_RATE: flatbuffers::VOffsetT = 6;
        pub const VT_DISK_FREE_SPACE: flatbuffers::VOffsetT = 8;
        pub const VT_DISK_UNINDEXED_DATA_SIZE: flatbuffers::VOffsetT = 10;
        pub const VT_MEMORY_USED: flatbuffers::VOffsetT = 12;
        pub const VT_URING_TASK_RATE: flatbuffers::VOffsetT = 14;
        pub const VT_URING_INFLIGHT_TASK_CNT: flatbuffers::VOffsetT = 16;
        pub const VT_URING_PENDING_TASK_CNT: flatbuffers::VOffsetT = 18;
        pub const VT_URING_TASK_AVG_LATENCY: flatbuffers::VOffsetT = 20;
        pub const VT_NETWORK_APPEND_RATE: flatbuffers::VOffsetT = 22;
        pub const VT_NETWORK_FETCH_RATE: flatbuffers::VOffsetT = 24;
        pub const VT_NETWORK_FAILED_APPEND_RATE: flatbuffers::VOffsetT = 26;
        pub const VT_NETWORK_FAILED_FETCH_RATE: flatbuffers::VOffsetT = 28;
        pub const VT_NETWORK_APPEND_AVG_LATENCY: flatbuffers::VOffsetT = 30;
        pub const VT_NETWORK_FETCH_AVG_LATENCY: flatbuffers::VOffsetT = 32;
        pub const VT_RANGE_MISSING_REPLICA_CNT: flatbuffers::VOffsetT = 34;
        pub const VT_RANGE_ACTIVE_CNT: flatbuffers::VOffsetT = 36;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DataNodeMetrics { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DataNodeMetricsArgs,
        ) -> flatbuffers::WIPOffset<DataNodeMetrics<'bldr>> {
            let mut builder = DataNodeMetricsBuilder::new(_fbb);
            builder.add_memory_used(args.memory_used);
            builder.add_disk_unindexed_data_size(args.disk_unindexed_data_size);
            builder.add_disk_free_space(args.disk_free_space);
            builder.add_disk_out_rate(args.disk_out_rate);
            builder.add_disk_in_rate(args.disk_in_rate);
            builder.add_uring_pending_task_cnt(args.uring_pending_task_cnt);
            builder.add_range_active_cnt(args.range_active_cnt);
            builder.add_range_missing_replica_cnt(args.range_missing_replica_cnt);
            builder.add_network_fetch_avg_latency(args.network_fetch_avg_latency);
            builder.add_network_append_avg_latency(args.network_append_avg_latency);
            builder.add_network_failed_fetch_rate(args.network_failed_fetch_rate);
            builder.add_network_failed_append_rate(args.network_failed_append_rate);
            builder.add_network_fetch_rate(args.network_fetch_rate);
            builder.add_network_append_rate(args.network_append_rate);
            builder.add_uring_task_avg_latency(args.uring_task_avg_latency);
            builder.add_uring_inflight_task_cnt(args.uring_inflight_task_cnt);
            builder.add_uring_task_rate(args.uring_task_rate);
            builder.finish()
        }

        pub fn unpack(&self) -> DataNodeMetricsT {
            let disk_in_rate = self.disk_in_rate();
            let disk_out_rate = self.disk_out_rate();
            let disk_free_space = self.disk_free_space();
            let disk_unindexed_data_size = self.disk_unindexed_data_size();
            let memory_used = self.memory_used();
            let uring_task_rate = self.uring_task_rate();
            let uring_inflight_task_cnt = self.uring_inflight_task_cnt();
            let uring_pending_task_cnt = self.uring_pending_task_cnt();
            let uring_task_avg_latency = self.uring_task_avg_latency();
            let network_append_rate = self.network_append_rate();
            let network_fetch_rate = self.network_fetch_rate();
            let network_failed_append_rate = self.network_failed_append_rate();
            let network_failed_fetch_rate = self.network_failed_fetch_rate();
            let network_append_avg_latency = self.network_append_avg_latency();
            let network_fetch_avg_latency = self.network_fetch_avg_latency();
            let range_missing_replica_cnt = self.range_missing_replica_cnt();
            let range_active_cnt = self.range_active_cnt();
            DataNodeMetricsT {
                disk_in_rate,
                disk_out_rate,
                disk_free_space,
                disk_unindexed_data_size,
                memory_used,
                uring_task_rate,
                uring_inflight_task_cnt,
                uring_pending_task_cnt,
                uring_task_avg_latency,
                network_append_rate,
                network_fetch_rate,
                network_failed_append_rate,
                network_failed_fetch_rate,
                network_append_avg_latency,
                network_fetch_avg_latency,
                range_missing_replica_cnt,
                range_active_cnt,
            }
        }

        #[inline]
        pub fn disk_in_rate(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(DataNodeMetrics::VT_DISK_IN_RATE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn disk_out_rate(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(DataNodeMetrics::VT_DISK_OUT_RATE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn disk_free_space(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(DataNodeMetrics::VT_DISK_FREE_SPACE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn disk_unindexed_data_size(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(DataNodeMetrics::VT_DISK_UNINDEXED_DATA_SIZE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn memory_used(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(DataNodeMetrics::VT_MEMORY_USED, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn uring_task_rate(&self) -> i16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i16>(DataNodeMetrics::VT_URING_TASK_RATE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn uring_inflight_task_cnt(&self) -> i16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i16>(DataNodeMetrics::VT_URING_INFLIGHT_TASK_CNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn uring_pending_task_cnt(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DataNodeMetrics::VT_URING_PENDING_TASK_CNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn uring_task_avg_latency(&self) -> i16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i16>(DataNodeMetrics::VT_URING_TASK_AVG_LATENCY, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn network_append_rate(&self) -> i16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i16>(DataNodeMetrics::VT_NETWORK_APPEND_RATE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn network_fetch_rate(&self) -> i16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i16>(DataNodeMetrics::VT_NETWORK_FETCH_RATE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn network_failed_append_rate(&self) -> i16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i16>(DataNodeMetrics::VT_NETWORK_FAILED_APPEND_RATE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn network_failed_fetch_rate(&self) -> i16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i16>(DataNodeMetrics::VT_NETWORK_FAILED_FETCH_RATE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn network_append_avg_latency(&self) -> i16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i16>(DataNodeMetrics::VT_NETWORK_APPEND_AVG_LATENCY, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn network_fetch_avg_latency(&self) -> i16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i16>(DataNodeMetrics::VT_NETWORK_FETCH_AVG_LATENCY, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn range_missing_replica_cnt(&self) -> i16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i16>(DataNodeMetrics::VT_RANGE_MISSING_REPLICA_CNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn range_active_cnt(&self) -> i16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i16>(DataNodeMetrics::VT_RANGE_ACTIVE_CNT, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DataNodeMetrics<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i64>("disk_in_rate", Self::VT_DISK_IN_RATE, false)?
                .visit_field::<i64>("disk_out_rate", Self::VT_DISK_OUT_RATE, false)?
                .visit_field::<i64>("disk_free_space", Self::VT_DISK_FREE_SPACE, false)?
                .visit_field::<i64>(
                    "disk_unindexed_data_size",
                    Self::VT_DISK_UNINDEXED_DATA_SIZE,
                    false,
                )?
                .visit_field::<i64>("memory_used", Self::VT_MEMORY_USED, false)?
                .visit_field::<i16>("uring_task_rate", Self::VT_URING_TASK_RATE, false)?
                .visit_field::<i16>(
                    "uring_inflight_task_cnt",
                    Self::VT_URING_INFLIGHT_TASK_CNT,
                    false,
                )?
                .visit_field::<i32>(
                    "uring_pending_task_cnt",
                    Self::VT_URING_PENDING_TASK_CNT,
                    false,
                )?
                .visit_field::<i16>(
                    "uring_task_avg_latency",
                    Self::VT_URING_TASK_AVG_LATENCY,
                    false,
                )?
                .visit_field::<i16>("network_append_rate", Self::VT_NETWORK_APPEND_RATE, false)?
                .visit_field::<i16>("network_fetch_rate", Self::VT_NETWORK_FETCH_RATE, false)?
                .visit_field::<i16>(
                    "network_failed_append_rate",
                    Self::VT_NETWORK_FAILED_APPEND_RATE,
                    false,
                )?
                .visit_field::<i16>(
                    "network_failed_fetch_rate",
                    Self::VT_NETWORK_FAILED_FETCH_RATE,
                    false,
                )?
                .visit_field::<i16>(
                    "network_append_avg_latency",
                    Self::VT_NETWORK_APPEND_AVG_LATENCY,
                    false,
                )?
                .visit_field::<i16>(
                    "network_fetch_avg_latency",
                    Self::VT_NETWORK_FETCH_AVG_LATENCY,
                    false,
                )?
                .visit_field::<i16>(
                    "range_missing_replica_cnt",
                    Self::VT_RANGE_MISSING_REPLICA_CNT,
                    false,
                )?
                .visit_field::<i16>("range_active_cnt", Self::VT_RANGE_ACTIVE_CNT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DataNodeMetricsArgs {
        pub disk_in_rate: i64,
        pub disk_out_rate: i64,
        pub disk_free_space: i64,
        pub disk_unindexed_data_size: i64,
        pub memory_used: i64,
        pub uring_task_rate: i16,
        pub uring_inflight_task_cnt: i16,
        pub uring_pending_task_cnt: i32,
        pub uring_task_avg_latency: i16,
        pub network_append_rate: i16,
        pub network_fetch_rate: i16,
        pub network_failed_append_rate: i16,
        pub network_failed_fetch_rate: i16,
        pub network_append_avg_latency: i16,
        pub network_fetch_avg_latency: i16,
        pub range_missing_replica_cnt: i16,
        pub range_active_cnt: i16,
    }
    impl<'a> Default for DataNodeMetricsArgs {
        #[inline]
        fn default() -> Self {
            DataNodeMetricsArgs {
                disk_in_rate: 0,
                disk_out_rate: 0,
                disk_free_space: 0,
                disk_unindexed_data_size: 0,
                memory_used: 0,
                uring_task_rate: 0,
                uring_inflight_task_cnt: 0,
                uring_pending_task_cnt: 0,
                uring_task_avg_latency: 0,
                network_append_rate: 0,
                network_fetch_rate: 0,
                network_failed_append_rate: 0,
                network_failed_fetch_rate: 0,
                network_append_avg_latency: 0,
                network_fetch_avg_latency: 0,
                range_missing_replica_cnt: 0,
                range_active_cnt: 0,
            }
        }
    }

    pub struct DataNodeMetricsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DataNodeMetricsBuilder<'a, 'b> {
        #[inline]
        pub fn add_disk_in_rate(&mut self, disk_in_rate: i64) {
            self.fbb_
                .push_slot::<i64>(DataNodeMetrics::VT_DISK_IN_RATE, disk_in_rate, 0);
        }
        #[inline]
        pub fn add_disk_out_rate(&mut self, disk_out_rate: i64) {
            self.fbb_
                .push_slot::<i64>(DataNodeMetrics::VT_DISK_OUT_RATE, disk_out_rate, 0);
        }
        #[inline]
        pub fn add_disk_free_space(&mut self, disk_free_space: i64) {
            self.fbb_
                .push_slot::<i64>(DataNodeMetrics::VT_DISK_FREE_SPACE, disk_free_space, 0);
        }
        #[inline]
        pub fn add_disk_unindexed_data_size(&mut self, disk_unindexed_data_size: i64) {
            self.fbb_.push_slot::<i64>(
                DataNodeMetrics::VT_DISK_UNINDEXED_DATA_SIZE,
                disk_unindexed_data_size,
                0,
            );
        }
        #[inline]
        pub fn add_memory_used(&mut self, memory_used: i64) {
            self.fbb_
                .push_slot::<i64>(DataNodeMetrics::VT_MEMORY_USED, memory_used, 0);
        }
        #[inline]
        pub fn add_uring_task_rate(&mut self, uring_task_rate: i16) {
            self.fbb_
                .push_slot::<i16>(DataNodeMetrics::VT_URING_TASK_RATE, uring_task_rate, 0);
        }
        #[inline]
        pub fn add_uring_inflight_task_cnt(&mut self, uring_inflight_task_cnt: i16) {
            self.fbb_.push_slot::<i16>(
                DataNodeMetrics::VT_URING_INFLIGHT_TASK_CNT,
                uring_inflight_task_cnt,
                0,
            );
        }
        #[inline]
        pub fn add_uring_pending_task_cnt(&mut self, uring_pending_task_cnt: i32) {
            self.fbb_.push_slot::<i32>(
                DataNodeMetrics::VT_URING_PENDING_TASK_CNT,
                uring_pending_task_cnt,
                0,
            );
        }
        #[inline]
        pub fn add_uring_task_avg_latency(&mut self, uring_task_avg_latency: i16) {
            self.fbb_.push_slot::<i16>(
                DataNodeMetrics::VT_URING_TASK_AVG_LATENCY,
                uring_task_avg_latency,
                0,
            );
        }
        #[inline]
        pub fn add_network_append_rate(&mut self, network_append_rate: i16) {
            self.fbb_.push_slot::<i16>(
                DataNodeMetrics::VT_NETWORK_APPEND_RATE,
                network_append_rate,
                0,
            );
        }
        #[inline]
        pub fn add_network_fetch_rate(&mut self, network_fetch_rate: i16) {
            self.fbb_.push_slot::<i16>(
                DataNodeMetrics::VT_NETWORK_FETCH_RATE,
                network_fetch_rate,
                0,
            );
        }
        #[inline]
        pub fn add_network_failed_append_rate(&mut self, network_failed_append_rate: i16) {
            self.fbb_.push_slot::<i16>(
                DataNodeMetrics::VT_NETWORK_FAILED_APPEND_RATE,
                network_failed_append_rate,
                0,
            );
        }
        #[inline]
        pub fn add_network_failed_fetch_rate(&mut self, network_failed_fetch_rate: i16) {
            self.fbb_.push_slot::<i16>(
                DataNodeMetrics::VT_NETWORK_FAILED_FETCH_RATE,
                network_failed_fetch_rate,
                0,
            );
        }
        #[inline]
        pub fn add_network_append_avg_latency(&mut self, network_append_avg_latency: i16) {
            self.fbb_.push_slot::<i16>(
                DataNodeMetrics::VT_NETWORK_APPEND_AVG_LATENCY,
                network_append_avg_latency,
                0,
            );
        }
        #[inline]
        pub fn add_network_fetch_avg_latency(&mut self, network_fetch_avg_latency: i16) {
            self.fbb_.push_slot::<i16>(
                DataNodeMetrics::VT_NETWORK_FETCH_AVG_LATENCY,
                network_fetch_avg_latency,
                0,
            );
        }
        #[inline]
        pub fn add_range_missing_replica_cnt(&mut self, range_missing_replica_cnt: i16) {
            self.fbb_.push_slot::<i16>(
                DataNodeMetrics::VT_RANGE_MISSING_REPLICA_CNT,
                range_missing_replica_cnt,
                0,
            );
        }
        #[inline]
        pub fn add_range_active_cnt(&mut self, range_active_cnt: i16) {
            self.fbb_
                .push_slot::<i16>(DataNodeMetrics::VT_RANGE_ACTIVE_CNT, range_active_cnt, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DataNodeMetricsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DataNodeMetricsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DataNodeMetrics<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DataNodeMetrics<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DataNodeMetrics");
            ds.field("disk_in_rate", &self.disk_in_rate());
            ds.field("disk_out_rate", &self.disk_out_rate());
            ds.field("disk_free_space", &self.disk_free_space());
            ds.field("disk_unindexed_data_size", &self.disk_unindexed_data_size());
            ds.field("memory_used", &self.memory_used());
            ds.field("uring_task_rate", &self.uring_task_rate());
            ds.field("uring_inflight_task_cnt", &self.uring_inflight_task_cnt());
            ds.field("uring_pending_task_cnt", &self.uring_pending_task_cnt());
            ds.field("uring_task_avg_latency", &self.uring_task_avg_latency());
            ds.field("network_append_rate", &self.network_append_rate());
            ds.field("network_fetch_rate", &self.network_fetch_rate());
            ds.field(
                "network_failed_append_rate",
                &self.network_failed_append_rate(),
            );
            ds.field(
                "network_failed_fetch_rate",
                &self.network_failed_fetch_rate(),
            );
            ds.field(
                "network_append_avg_latency",
                &self.network_append_avg_latency(),
            );
            ds.field(
                "network_fetch_avg_latency",
                &self.network_fetch_avg_latency(),
            );
            ds.field(
                "range_missing_replica_cnt",
                &self.range_missing_replica_cnt(),
            );
            ds.field("range_active_cnt", &self.range_active_cnt());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct DataNodeMetricsT {
        pub disk_in_rate: i64,
        pub disk_out_rate: i64,
        pub disk_free_space: i64,
        pub disk_unindexed_data_size: i64,
        pub memory_used: i64,
        pub uring_task_rate: i16,
        pub uring_inflight_task_cnt: i16,
        pub uring_pending_task_cnt: i32,
        pub uring_task_avg_latency: i16,
        pub network_append_rate: i16,
        pub network_fetch_rate: i16,
        pub network_failed_append_rate: i16,
        pub network_failed_fetch_rate: i16,
        pub network_append_avg_latency: i16,
        pub network_fetch_avg_latency: i16,
        pub range_missing_replica_cnt: i16,
        pub range_active_cnt: i16,
    }
    impl Default for DataNodeMetricsT {
        fn default() -> Self {
            Self {
                disk_in_rate: 0,
                disk_out_rate: 0,
                disk_free_space: 0,
                disk_unindexed_data_size: 0,
                memory_used: 0,
                uring_task_rate: 0,
                uring_inflight_task_cnt: 0,
                uring_pending_task_cnt: 0,
                uring_task_avg_latency: 0,
                network_append_rate: 0,
                network_fetch_rate: 0,
                network_failed_append_rate: 0,
                network_failed_fetch_rate: 0,
                network_append_avg_latency: 0,
                network_fetch_avg_latency: 0,
                range_missing_replica_cnt: 0,
                range_active_cnt: 0,
            }
        }
    }
    impl DataNodeMetricsT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<DataNodeMetrics<'b>> {
            let disk_in_rate = self.disk_in_rate;
            let disk_out_rate = self.disk_out_rate;
            let disk_free_space = self.disk_free_space;
            let disk_unindexed_data_size = self.disk_unindexed_data_size;
            let memory_used = self.memory_used;
            let uring_task_rate = self.uring_task_rate;
            let uring_inflight_task_cnt = self.uring_inflight_task_cnt;
            let uring_pending_task_cnt = self.uring_pending_task_cnt;
            let uring_task_avg_latency = self.uring_task_avg_latency;
            let network_append_rate = self.network_append_rate;
            let network_fetch_rate = self.network_fetch_rate;
            let network_failed_append_rate = self.network_failed_append_rate;
            let network_failed_fetch_rate = self.network_failed_fetch_rate;
            let network_append_avg_latency = self.network_append_avg_latency;
            let network_fetch_avg_latency = self.network_fetch_avg_latency;
            let range_missing_replica_cnt = self.range_missing_replica_cnt;
            let range_active_cnt = self.range_active_cnt;
            DataNodeMetrics::create(
                _fbb,
                &DataNodeMetricsArgs {
                    disk_in_rate,
                    disk_out_rate,
                    disk_free_space,
                    disk_unindexed_data_size,
                    memory_used,
                    uring_task_rate,
                    uring_inflight_task_cnt,
                    uring_pending_task_cnt,
                    uring_task_avg_latency,
                    network_append_rate,
                    network_fetch_rate,
                    network_failed_append_rate,
                    network_failed_fetch_rate,
                    network_append_avg_latency,
                    network_fetch_avg_latency,
                    range_missing_replica_cnt,
                    range_active_cnt,
                },
            )
        }
    }
    pub enum ReportMetricsResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ReportMetricsResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReportMetricsResponse<'a> {
        type Inner = ReportMetricsResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ReportMetricsResponse<'a> {
        pub const VT_DATA_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_STATUS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReportMetricsResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReportMetricsResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<ReportMetricsResponse<'bldr>> {
            let mut builder = ReportMetricsResponseBuilder::new(_fbb);
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            if let Some(x) = args.data_node {
                builder.add_data_node(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ReportMetricsResponseT {
            let data_node = self.data_node().map(|x| Box::new(x.unpack()));
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            ReportMetricsResponseT { data_node, status }
        }

        #[inline]
        pub fn data_node(&self) -> Option<DataNode<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<DataNode>>(
                    ReportMetricsResponse::VT_DATA_NODE,
                    None,
                )
            }
        }
        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(
                        ReportMetricsResponse::VT_STATUS,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ReportMetricsResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<DataNode>>(
                    "data_node",
                    Self::VT_DATA_NODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ReportMetricsResponseArgs<'a> {
        pub data_node: Option<flatbuffers::WIPOffset<DataNode<'a>>>,
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
    }
    impl<'a> Default for ReportMetricsResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            ReportMetricsResponseArgs {
                data_node: None,
                status: None, // required field
            }
        }
    }

    pub struct ReportMetricsResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReportMetricsResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_data_node(&mut self, data_node: flatbuffers::WIPOffset<DataNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<DataNode>>(
                    ReportMetricsResponse::VT_DATA_NODE,
                    data_node,
                );
        }
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    ReportMetricsResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReportMetricsResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReportMetricsResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReportMetricsResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, ReportMetricsResponse::VT_STATUS, "status");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ReportMetricsResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ReportMetricsResponse");
            ds.field("data_node", &self.data_node());
            ds.field("status", &self.status());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ReportMetricsResponseT {
        pub data_node: Option<Box<DataNodeT>>,
        pub status: Box<StatusT>,
    }
    impl Default for ReportMetricsResponseT {
        fn default() -> Self {
            Self {
                data_node: None,
                status: Default::default(),
            }
        }
    }
    impl ReportMetricsResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<ReportMetricsResponse<'b>> {
            let data_node = self.data_node.as_ref().map(|x| x.pack(_fbb));
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            ReportMetricsResponse::create(_fbb, &ReportMetricsResponseArgs { data_node, status })
        }
    }
    pub enum DescribePlacementManagerClusterRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DescribePlacementManagerClusterRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DescribePlacementManagerClusterRequest<'a> {
        type Inner = DescribePlacementManagerClusterRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DescribePlacementManagerClusterRequest<'a> {
        pub const VT_DATA_NODE: flatbuffers::VOffsetT = 4;
        pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DescribePlacementManagerClusterRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DescribePlacementManagerClusterRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<DescribePlacementManagerClusterRequest<'bldr>> {
            let mut builder = DescribePlacementManagerClusterRequestBuilder::new(_fbb);
            builder.add_timeout_ms(args.timeout_ms);
            if let Some(x) = args.data_node {
                builder.add_data_node(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> DescribePlacementManagerClusterRequestT {
            let data_node = {
                let x = self.data_node();
                Box::new(x.unpack())
            };
            let timeout_ms = self.timeout_ms();
            DescribePlacementManagerClusterRequestT {
                data_node,
                timeout_ms,
            }
        }

        #[inline]
        pub fn data_node(&self) -> DataNode<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<DataNode>>(
                        DescribePlacementManagerClusterRequest::VT_DATA_NODE,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn timeout_ms(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(
                        DescribePlacementManagerClusterRequest::VT_TIMEOUT_MS,
                        Some(0),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DescribePlacementManagerClusterRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<DataNode>>(
                    "data_node",
                    Self::VT_DATA_NODE,
                    true,
                )?
                .visit_field::<i32>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DescribePlacementManagerClusterRequestArgs<'a> {
        pub data_node: Option<flatbuffers::WIPOffset<DataNode<'a>>>,
        pub timeout_ms: i32,
    }
    impl<'a> Default for DescribePlacementManagerClusterRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            DescribePlacementManagerClusterRequestArgs {
                data_node: None, // required field
                timeout_ms: 0,
            }
        }
    }

    pub struct DescribePlacementManagerClusterRequestBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DescribePlacementManagerClusterRequestBuilder<'a, 'b> {
        #[inline]
        pub fn add_data_node(&mut self, data_node: flatbuffers::WIPOffset<DataNode<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<DataNode>>(
                    DescribePlacementManagerClusterRequest::VT_DATA_NODE,
                    data_node,
                );
        }
        #[inline]
        pub fn add_timeout_ms(&mut self, timeout_ms: i32) {
            self.fbb_.push_slot::<i32>(
                DescribePlacementManagerClusterRequest::VT_TIMEOUT_MS,
                timeout_ms,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DescribePlacementManagerClusterRequestBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DescribePlacementManagerClusterRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DescribePlacementManagerClusterRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(
                o,
                DescribePlacementManagerClusterRequest::VT_DATA_NODE,
                "data_node",
            );
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DescribePlacementManagerClusterRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DescribePlacementManagerClusterRequest");
            ds.field("data_node", &self.data_node());
            ds.field("timeout_ms", &self.timeout_ms());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct DescribePlacementManagerClusterRequestT {
        pub data_node: Box<DataNodeT>,
        pub timeout_ms: i32,
    }
    impl Default for DescribePlacementManagerClusterRequestT {
        fn default() -> Self {
            Self {
                data_node: Default::default(),
                timeout_ms: 0,
            }
        }
    }
    impl DescribePlacementManagerClusterRequestT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<DescribePlacementManagerClusterRequest<'b>> {
            let data_node = Some({
                let x = &self.data_node;
                x.pack(_fbb)
            });
            let timeout_ms = self.timeout_ms;
            DescribePlacementManagerClusterRequest::create(
                _fbb,
                &DescribePlacementManagerClusterRequestArgs {
                    data_node,
                    timeout_ms,
                },
            )
        }
    }
    pub enum DescribePlacementManagerClusterResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DescribePlacementManagerClusterResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DescribePlacementManagerClusterResponse<'a> {
        type Inner = DescribePlacementManagerClusterResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DescribePlacementManagerClusterResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_CLUSTER: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DescribePlacementManagerClusterResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DescribePlacementManagerClusterResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<DescribePlacementManagerClusterResponse<'bldr>> {
            let mut builder = DescribePlacementManagerClusterResponseBuilder::new(_fbb);
            if let Some(x) = args.cluster {
                builder.add_cluster(x);
            }
            if let Some(x) = args.status {
                builder.add_status(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> DescribePlacementManagerClusterResponseT {
            let status = {
                let x = self.status();
                Box::new(x.unpack())
            };
            let cluster = {
                let x = self.cluster();
                Box::new(x.unpack())
            };
            DescribePlacementManagerClusterResponseT { status, cluster }
        }

        #[inline]
        pub fn status(&self) -> Status<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Status>>(
                        DescribePlacementManagerClusterResponse::VT_STATUS,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn cluster(&self) -> PlacementManagerCluster<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<PlacementManagerCluster>>(
                        DescribePlacementManagerClusterResponse::VT_CLUSTER,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DescribePlacementManagerClusterResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Status>>(
                    "status",
                    Self::VT_STATUS,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<PlacementManagerCluster>>(
                    "cluster",
                    Self::VT_CLUSTER,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct DescribePlacementManagerClusterResponseArgs<'a> {
        pub status: Option<flatbuffers::WIPOffset<Status<'a>>>,
        pub cluster: Option<flatbuffers::WIPOffset<PlacementManagerCluster<'a>>>,
    }
    impl<'a> Default for DescribePlacementManagerClusterResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            DescribePlacementManagerClusterResponseArgs {
                status: None,  // required field
                cluster: None, // required field
            }
        }
    }

    pub struct DescribePlacementManagerClusterResponseBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DescribePlacementManagerClusterResponseBuilder<'a, 'b> {
        #[inline]
        pub fn add_status(&mut self, status: flatbuffers::WIPOffset<Status<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Status>>(
                    DescribePlacementManagerClusterResponse::VT_STATUS,
                    status,
                );
        }
        #[inline]
        pub fn add_cluster(
            &mut self,
            cluster: flatbuffers::WIPOffset<PlacementManagerCluster<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<PlacementManagerCluster>>(
                    DescribePlacementManagerClusterResponse::VT_CLUSTER,
                    cluster,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DescribePlacementManagerClusterResponseBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DescribePlacementManagerClusterResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DescribePlacementManagerClusterResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(
                o,
                DescribePlacementManagerClusterResponse::VT_STATUS,
                "status",
            );
            self.fbb_.required(
                o,
                DescribePlacementManagerClusterResponse::VT_CLUSTER,
                "cluster",
            );
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DescribePlacementManagerClusterResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DescribePlacementManagerClusterResponse");
            ds.field("status", &self.status());
            ds.field("cluster", &self.cluster());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct DescribePlacementManagerClusterResponseT {
        pub status: Box<StatusT>,
        pub cluster: Box<PlacementManagerClusterT>,
    }
    impl Default for DescribePlacementManagerClusterResponseT {
        fn default() -> Self {
            Self {
                status: Default::default(),
                cluster: Default::default(),
            }
        }
    }
    impl DescribePlacementManagerClusterResponseT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<DescribePlacementManagerClusterResponse<'b>> {
            let status = Some({
                let x = &self.status;
                x.pack(_fbb)
            });
            let cluster = Some({
                let x = &self.cluster;
                x.pack(_fbb)
            });
            DescribePlacementManagerClusterResponse::create(
                _fbb,
                &DescribePlacementManagerClusterResponseArgs { status, cluster },
            )
        }
    }
} // pub mod header
